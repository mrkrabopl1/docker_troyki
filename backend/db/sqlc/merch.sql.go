// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: merch.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearDiscounts = `-- name: ClearDiscounts :exec
DELETE FROM discount
`

func (q *Queries) ClearDiscounts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearDiscounts)
	return err
}

const getCategoryByTypeId = `-- name: GetCategoryByTypeId :one
SELECT 
    pt.category AS product_category,
    pt.type_name AS type_name,
    pt.enum_value AS type_enum
FROM 
    product_types pt
WHERE 
    pt.id = $1
`

type GetCategoryByTypeIdRow struct {
	ProductCategory ProductSourceEnum `json:"product_category"`
	TypeName        string            `json:"type_name"`
	TypeEnum        string            `json:"type_enum"`
}

func (q *Queries) GetCategoryByTypeId(ctx context.Context, typeID int32) (GetCategoryByTypeIdRow, error) {
	row := q.db.QueryRow(ctx, getCategoryByTypeId, typeID)
	var i GetCategoryByTypeIdRow
	err := row.Scan(&i.ProductCategory, &i.TypeName, &i.TypeEnum)
	return i, err
}

const getClothesInfoById = `-- name: GetClothesInfoById :one
SELECT
    info,
    image_path,
    name,
    article,
    clothes.minprice,
    description,
    date,
    image_count,
    discount.value AS discount_value
FROM clothes
    LEFT JOIN discount ON clothes.id = productid
WHERE clothes.id = $1
`

type GetClothesInfoByIdRow struct {
	Info          []byte      `json:"info"`
	ImagePath     string      `json:"image_path"`
	Name          string      `json:"name"`
	Article       pgtype.Text `json:"article"`
	Minprice      int32       `json:"minprice"`
	Description   pgtype.Text `json:"description"`
	Date          pgtype.Text `json:"date"`
	ImageCount    int32       `json:"image_count"`
	DiscountValue []byte      `json:"discount_value"`
}

func (q *Queries) GetClothesInfoById(ctx context.Context, id int32) (GetClothesInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getClothesInfoById, id)
	var i GetClothesInfoByIdRow
	err := row.Scan(
		&i.Info,
		&i.ImagePath,
		&i.Name,
		&i.Article,
		&i.Minprice,
		&i.Description,
		&i.Date,
		&i.ImageCount,
		&i.DiscountValue,
	)
	return i, err
}

const getCombinedFiltersByString = `-- name: GetCombinedFiltersByString :one
WITH combined_products AS (
    -- Data from snickers (only shoe sizes)
    SELECT 
        s.minprice AS minprice,
        s.maxprice AS maxprice,
        s.firm,
        s."3.5", s."4", s."4.5", s."5", s."5.5", 
        s."6", s."6.5", s."7", s."7.5", s."8", 
        s."8.5", s."9", s."9.5", s."10", s."10.5", 
        s."11", s."11.5", s."12", s."12.5", s."13",
        NULL AS "XS", -- These will always be NULL for snickers
        NULL AS "S",
        NULL AS "M",
        NULL AS "L",
        NULL AS "XL",
        NULL AS "XXL"
    FROM snickers s
    WHERE s.name ILIKE '%' || $1::text || '%'
    
    UNION ALL
    
    -- Data from solomerch (no size columns)
    SELECT 
        sm.minprice AS minprice,
        sm.minprice AS maxprice,
        sm.firm,
        NULL, NULL, NULL, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL
    FROM solomerch sm
    WHERE sm.name ILIKE '%' || $1::text || '%'
    
    UNION ALL
    
    -- Data from clothes (only clothing sizes)
    SELECT 
        cl.minprice AS minprice,
        cl.maxprice AS maxprice,
        cl.firm,
        NULL, NULL, NULL, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        cl."XS",
        cl."S",
        cl."M",
        cl."L",
        cl."XL",
        cl."XXL"
    FROM clothes cl
    WHERE cl.name ILIKE '%' || $1::text || '%'
),
firm_counts AS (
    SELECT firm, COUNT(*) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT
    -- Shoe sizes (only from snickers)
    COUNT(NULLIF(cp."3.5", 0)) AS "3.5",
    COUNT(NULLIF(cp."4", 0)) AS "4",
    COUNT(NULLIF(cp."4.5", 0)) AS "4.5",
    COUNT(NULLIF(cp."5", 0)) AS "5",
    COUNT(NULLIF(cp."5.5", 0)) AS "5.5",
    COUNT(NULLIF(cp."6", 0)) AS "6",
    COUNT(NULLIF(cp."6.5", 0)) AS "6.5",
    COUNT(NULLIF(cp."7", 0)) AS "7",
    COUNT(NULLIF(cp."7.5", 0)) AS "7.5",
    COUNT(NULLIF(cp."8", 0)) AS "8",
    COUNT(NULLIF(cp."8.5", 0)) AS "8.5",
    COUNT(NULLIF(cp."9", 0)) AS "9",
    COUNT(NULLIF(cp."9.5", 0)) AS "9.5",
    COUNT(NULLIF(cp."10", 0)) AS "10",
    COUNT(NULLIF(cp."10.5", 0)) AS "10.5",
    COUNT(NULLIF(cp."11", 0)) AS "11",
    COUNT(NULLIF(cp."11.5", 0)) AS "11.5",
    COUNT(NULLIF(cp."12", 0)) AS "12",
    COUNT(NULLIF(cp."12.5", 0)) AS "12.5",
    COUNT(NULLIF(cp."13", 0)) AS "13",
    
    -- Clothing sizes (only from clothes)
    COUNT(NULLIF(cp."XS", 0)) AS "XS",
    COUNT(NULLIF(cp."S", 0)) AS "S",
    COUNT(NULLIF(cp."M", 0)) AS "M",
    COUNT(NULLIF(cp."L", 0)) AS "L",
    COUNT(NULLIF(cp."XL", 0)) AS "XL",
    COUNT(NULLIF(cp."XXL", 0)) AS "XXL",
    
    -- Price ranges
    MIN(cp.minprice) AS min_price,
    MAX(cp.maxprice) AS max_price,
    
    -- Firm counts
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) FILTER (WHERE fc.firm IS NOT NULL) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
GROUP BY 1
`

type GetCombinedFiltersByStringRow struct {
	_35          int64       `json:"3.5"`
	_4           int64       `json:"4"`
	_45          int64       `json:"4.5"`
	_5           int64       `json:"5"`
	_55          int64       `json:"5.5"`
	_6           int64       `json:"6"`
	_65          int64       `json:"6.5"`
	_7           int64       `json:"7"`
	_75          int64       `json:"7.5"`
	_8           int64       `json:"8"`
	_85          int64       `json:"8.5"`
	_9           int64       `json:"9"`
	_95          int64       `json:"9.5"`
	_10          int64       `json:"10"`
	_105         int64       `json:"10.5"`
	_11          int64       `json:"11"`
	_115         int64       `json:"11.5"`
	_12          int64       `json:"12"`
	_125         int64       `json:"12.5"`
	_13          int64       `json:"13"`
	XS           int64       `json:"XS"`
	S            int64       `json:"S"`
	M            int64       `json:"M"`
	L            int64       `json:"L"`
	XL           int64       `json:"XL"`
	XXL          int64       `json:"XXL"`
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetCombinedFiltersByString(ctx context.Context, dollar_1 string) (GetCombinedFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getCombinedFiltersByString, dollar_1)
	var i GetCombinedFiltersByStringRow
	err := row.Scan(
		&i._35,
		&i._4,
		&i._45,
		&i._5,
		&i._55,
		&i._6,
		&i._65,
		&i._7,
		&i._75,
		&i._8,
		&i._85,
		&i._9,
		&i._95,
		&i._10,
		&i._105,
		&i._11,
		&i._115,
		&i._12,
		&i._125,
		&i._13,
		&i.XS,
		&i.S,
		&i.M,
		&i.L,
		&i.XL,
		&i.XXL,
		&i.MinPrice,
		&i.MaxPrice,
		&i.FirmCountMap,
	)
	return i, err
}

const getCountIdByName = `-- name: GetCountIdByName :many
SELECT firm,
    COUNT(id) count
FROM snickers
WHERE name ILIKE '%' || CAST($1 AS text) || '%'
GROUP BY $1
`

type GetCountIdByNameRow struct {
	Firm  string `json:"firm"`
	Count int64  `json:"count"`
}

func (q *Queries) GetCountIdByName(ctx context.Context, dollar_1 string) ([]GetCountIdByNameRow, error) {
	rows, err := q.db.Query(ctx, getCountIdByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountIdByNameRow
	for rows.Next() {
		var i GetCountIdByNameRow
		if err := rows.Scan(&i.Firm, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfCollectionsOrFirms = `-- name: GetCountOfCollectionsOrFirms :one
SELECT COUNT(snickers.id) AS count 
FROM snickers
WHERE firm = $1
    OR line = $2
`

type GetCountOfCollectionsOrFirmsParams struct {
	Firm string `json:"firm"`
	Line string `json:"line"`
}

func (q *Queries) GetCountOfCollectionsOrFirms(ctx context.Context, arg GetCountOfCollectionsOrFirmsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfCollectionsOrFirms, arg.Firm, arg.Line)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFiltersByString = `-- name: GetFiltersByString :one
WITH combined_products AS (
    -- Данные из snickers
    SELECT 
        pr.global_id,
        s.firm,
        s.minprice,
        s.maxprice,
        s."3.5", s."4", s."4.5", s."5", s."5.5", 
        s."6", s."6.5", s."7", s."7.5", s."8", 
        s."8.5", s."9", s."9.5", s."10", s."10.5", 
        s."11", s."11.5", s."12", s."12.5", s."13",
        NULL::integer AS "XS",
        NULL::integer AS "S",
        NULL::integer AS "M",
        NULL::integer AS "L",
        NULL::integer AS "XL",
        NULL::integer AS "XXL",
        s.type 
    FROM snickers s
    JOIN product_registry pr ON pr.internal_id = s.id AND pr.source_table = 'snickers'
    WHERE s.name ILIKE '%' || $1::text || '%'
    
    UNION ALL
    
    -- Данные из solomerch
    SELECT 
        pr.global_id,
        sm.firm,
        sm.minprice,
        sm.minprice,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, 
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        sm.type
    FROM solomerch sm
    JOIN product_registry pr ON pr.internal_id = sm.id AND pr.source_table = 'solomerch'
    WHERE sm.name ILIKE '%' || $1::text || '%'
    
    UNION ALL
    
    -- Данные из clothes
    SELECT 
        pr.global_id,
        cl.firm,
        cl.minprice,
        cl.maxprice,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, 
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        cl.XS,
        cl.S,
        cl.M,
        cl.L,
        cl.XL,
        cl.XXL,
        cl.type
    FROM clothes cl
     JOIN product_registry pr ON pr.internal_id = cl.id AND pr.source_table = 'clothes'
    WHERE cl.name ILIKE '%' || $1::text || '%'
),
firm_counts AS (
    SELECT firm, COUNT(global_id) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT
    COUNT(NULLIF(cp."3.5", 0)) AS "3.5",
    COUNT(NULLIF(cp."4", 0)) AS "4",
    COUNT(NULLIF(cp."4.5", 0)) AS "4.5",
    COUNT(NULLIF(cp."5", 0)) AS "5",
    COUNT(NULLIF(cp."5.5", 0)) AS "5.5",
    COUNT(NULLIF(cp."6", 0)) AS "6",
    COUNT(NULLIF(cp."6.5", 0)) AS "6.5",
    COUNT(NULLIF(cp."7", 0)) AS "7",
    COUNT(NULLIF(cp."7.5", 0)) AS "7.5",
    COUNT(NULLIF(cp."8", 0)) AS "8",
    COUNT(NULLIF(cp."8.5", 0)) AS "8.5",
    COUNT(NULLIF(cp."9", 0)) AS "9",
    COUNT(NULLIF(cp."9.5", 0)) AS "9.5",
    COUNT(NULLIF(cp."10", 0)) AS "10",
    COUNT(NULLIF(cp."10.5", 0)) AS "10.5",
    COUNT(NULLIF(cp."11", 0)) AS "11",
    COUNT(NULLIF(cp."11.5", 0)) AS "11.5",
    COUNT(NULLIF(cp."12", 0)) AS "12",
    COUNT(NULLIF(cp."12.5", 0)) AS "12.5",
    COUNT(NULLIF(cp."13", 0)) AS "13",
    COUNT(NULLIF(cp."XS", 0)) AS "XS",
    COUNT(NULLIF(cp."S", 0)) AS "S",
    COUNT(NULLIF(cp."M", 0)) AS "M",
    COUNT(NULLIF(cp."L", 0)) AS "L",
    COUNT(NULLIF(cp."XL", 0)) AS "XL",
    COUNT(NULLIF(cp."XXL", 0)) AS "XXL",
    MIN(cp.minprice) AS min,
    MAX(cp.maxprice) AS max,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
GROUP BY ()
`

type GetFiltersByStringRow struct {
	_35          int64       `json:"3.5"`
	_4           int64       `json:"4"`
	_45          int64       `json:"4.5"`
	_5           int64       `json:"5"`
	_55          int64       `json:"5.5"`
	_6           int64       `json:"6"`
	_65          int64       `json:"6.5"`
	_7           int64       `json:"7"`
	_75          int64       `json:"7.5"`
	_8           int64       `json:"8"`
	_85          int64       `json:"8.5"`
	_9           int64       `json:"9"`
	_95          int64       `json:"9.5"`
	_10          int64       `json:"10"`
	_105         int64       `json:"10.5"`
	_11          int64       `json:"11"`
	_115         int64       `json:"11.5"`
	_12          int64       `json:"12"`
	_125         int64       `json:"12.5"`
	_13          int64       `json:"13"`
	XS           int64       `json:"XS"`
	S            int64       `json:"S"`
	M            int64       `json:"M"`
	L            int64       `json:"L"`
	XL           int64       `json:"XL"`
	XXL          int64       `json:"XXL"`
	Min          interface{} `json:"min"`
	Max          interface{} `json:"max"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetFiltersByString(ctx context.Context, dollar_1 string) (GetFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getFiltersByString, dollar_1)
	var i GetFiltersByStringRow
	err := row.Scan(
		&i._35,
		&i._4,
		&i._45,
		&i._5,
		&i._55,
		&i._6,
		&i._65,
		&i._7,
		&i._75,
		&i._8,
		&i._85,
		&i._9,
		&i._95,
		&i._10,
		&i._105,
		&i._11,
		&i._115,
		&i._12,
		&i._125,
		&i._13,
		&i.XS,
		&i.S,
		&i.M,
		&i.L,
		&i.XL,
		&i.XXL,
		&i.Min,
		&i.Max,
		&i.FirmCountMap,
	)
	return i, err
}

const getFiltersFromClothes = `-- name: GetFiltersFromClothes :one
WITH combined_products AS (
    SELECT 
        pr.global_id,
        cl.firm,
        cl.minprice,
        cl.maxprice,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, 
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
        NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    cl.xs::integer AS "XS",
    cl.s::integer AS "S",
    cl.m::integer AS "M",
    cl.l::integer AS "L",
    cl.xl::integer AS "XL",
    cl.xxl::integer AS "XXL",
        cl.type
    FROM clothes cl
     JOIN product_registry pr ON pr.internal_id = cl.id AND pr.source_table = 'clothes'
    WHERE cl.name ILIKE '%' || $1::text || '%'
        AND ($2::numeric IS NULL OR cl.minprice >= $2)  -- Фильтр по мин. цене
        AND ($3::numeric IS NULL OR cl.maxprice <= $3)      -- Фильтр по макс. цене
),
firm_counts AS (
    SELECT firm, COUNT(global_id) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT
       COUNT(NULLIF(cp."XS", 0)) AS "XS",
    COUNT(NULLIF(cp."S", 0)) AS "S",
    COUNT(NULLIF(cp."M", 0)) AS "M",
    COUNT(NULLIF(cp."L", 0)) AS "L",
    COUNT(NULLIF(cp."XL", 0)) AS "XL",
    COUNT(NULLIF(cp."XXL", 0)) AS "XXL",
    MIN(cp.minprice)::float AS min,
    MAX(cp.maxprice)::float AS max,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
GROUP BY ()
`

type GetFiltersFromClothesParams struct {
	Name     string         `json:"name"`
	MinPrice pgtype.Numeric `json:"min_price"`
	MaxPrice pgtype.Numeric `json:"max_price"`
}

type GetFiltersFromClothesRow struct {
	XS           int64   `json:"XS"`
	S            int64   `json:"S"`
	M            int64   `json:"M"`
	L            int64   `json:"L"`
	XL           int64   `json:"XL"`
	XXL          int64   `json:"XXL"`
	Min          float64 `json:"min"`
	Max          float64 `json:"max"`
	FirmCountMap []byte  `json:"firm_count_map"`
}

func (q *Queries) GetFiltersFromClothes(ctx context.Context, arg GetFiltersFromClothesParams) (GetFiltersFromClothesRow, error) {
	row := q.db.QueryRow(ctx, getFiltersFromClothes, arg.Name, arg.MinPrice, arg.MaxPrice)
	var i GetFiltersFromClothesRow
	err := row.Scan(
		&i.XS,
		&i.S,
		&i.M,
		&i.L,
		&i.XL,
		&i.XXL,
		&i.Min,
		&i.Max,
		&i.FirmCountMap,
	)
	return i, err
}

const getFiltersFromMerchByType = `-- name: GetFiltersFromMerchByType :one
WITH combined_products AS (
    SELECT 
        pr.global_id,
        sm.firm,
        sm.minprice,
        sm.minprice AS maxprice,  -- Исправлено: дублирование minprice
        sm.type
    FROM solomerch sm
    JOIN product_registry pr ON pr.internal_id = sm.id AND pr.source_table = 'solomerch'
    WHERE sm.name ILIKE '%' || $1::text || '%'
      AND ($2::numeric IS NULL OR sm.minprice >= $2)  -- Исправлено: s → sm
),
firm_counts AS (
    SELECT firm, COUNT(global_id) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT
    MIN(cp.minprice)::float AS min,
    MAX(cp.maxprice)::float AS max,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
`

type GetFiltersFromMerchByTypeParams struct {
	Name     string         `json:"name"`
	MinPrice pgtype.Numeric `json:"min_price"`
}

type GetFiltersFromMerchByTypeRow struct {
	Min          float64 `json:"min"`
	Max          float64 `json:"max"`
	FirmCountMap []byte  `json:"firm_count_map"`
}

func (q *Queries) GetFiltersFromMerchByType(ctx context.Context, arg GetFiltersFromMerchByTypeParams) (GetFiltersFromMerchByTypeRow, error) {
	row := q.db.QueryRow(ctx, getFiltersFromMerchByType, arg.Name, arg.MinPrice)
	var i GetFiltersFromMerchByTypeRow
	err := row.Scan(&i.Min, &i.Max, &i.FirmCountMap)
	return i, err
}

const getFiltersFromSnickers = `-- name: GetFiltersFromSnickers :one
WITH combined_products AS (
    -- Данные из snickers
    SELECT 
        pr.global_id,
        s.firm,
        s.minprice,
        s.maxprice,
        s."3.5", s."4", s."4.5", s."5", s."5.5", 
        s."6", s."6.5", s."7", s."7.5", s."8", 
        s."8.5", s."9", s."9.5", s."10", s."10.5", 
        s."11", s."11.5", s."12", s."12.5", s."13",
        s.type
    FROM snickers s
    JOIN product_registry pr ON pr.internal_id = s.id AND pr.source_table = 'snickers'
     WHERE 
        s.name ILIKE '%' || $1::text || '%' 
        AND ($2::numeric IS NULL OR s.minprice >= $2)  -- Фильтр по мин. цене
        AND ($3::numeric IS NULL OR s.maxprice <= $3)   -- Фильтр по макс. цене

),
firm_counts AS (
    SELECT firm, COUNT(global_id) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT
    COUNT(NULLIF(cp."3.5", 0)) AS "3.5",
    COUNT(NULLIF(cp."4", 0)) AS "4",
    COUNT(NULLIF(cp."4.5", 0)) AS "4.5",
    COUNT(NULLIF(cp."5", 0)) AS "5",
    COUNT(NULLIF(cp."5.5", 0)) AS "5.5",
    COUNT(NULLIF(cp."6", 0)) AS "6",
    COUNT(NULLIF(cp."6.5", 0)) AS "6.5",
    COUNT(NULLIF(cp."7", 0)) AS "7",
    COUNT(NULLIF(cp."7.5", 0)) AS "7.5",
    COUNT(NULLIF(cp."8", 0)) AS "8",
    COUNT(NULLIF(cp."8.5", 0)) AS "8.5",
    COUNT(NULLIF(cp."9", 0)) AS "9",
    COUNT(NULLIF(cp."9.5", 0)) AS "9.5",
    COUNT(NULLIF(cp."10", 0)) AS "10",
    COUNT(NULLIF(cp."10.5", 0)) AS "10.5",
    COUNT(NULLIF(cp."11", 0)) AS "11",
    COUNT(NULLIF(cp."11.5", 0)) AS "11.5",
    COUNT(NULLIF(cp."12", 0)) AS "12",
    COUNT(NULLIF(cp."12.5", 0)) AS "12.5",
    COUNT(NULLIF(cp."13", 0)) AS "13",
    MIN(cp.minprice)::float AS min,
    MAX(cp.maxprice)::float AS max,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
GROUP BY ()
`

type GetFiltersFromSnickersParams struct {
	Name     string         `json:"name"`
	MinPrice pgtype.Numeric `json:"min_price"`
	MaxPrice pgtype.Numeric `json:"max_price"`
}

type GetFiltersFromSnickersRow struct {
	_35          int64   `json:"3.5"`
	_4           int64   `json:"4"`
	_45          int64   `json:"4.5"`
	_5           int64   `json:"5"`
	_55          int64   `json:"5.5"`
	_6           int64   `json:"6"`
	_65          int64   `json:"6.5"`
	_7           int64   `json:"7"`
	_75          int64   `json:"7.5"`
	_8           int64   `json:"8"`
	_85          int64   `json:"8.5"`
	_9           int64   `json:"9"`
	_95          int64   `json:"9.5"`
	_10          int64   `json:"10"`
	_105         int64   `json:"10.5"`
	_11          int64   `json:"11"`
	_115         int64   `json:"11.5"`
	_12          int64   `json:"12"`
	_125         int64   `json:"12.5"`
	_13          int64   `json:"13"`
	Min          float64 `json:"min"`
	Max          float64 `json:"max"`
	FirmCountMap []byte  `json:"firm_count_map"`
}

func (q *Queries) GetFiltersFromSnickers(ctx context.Context, arg GetFiltersFromSnickersParams) (GetFiltersFromSnickersRow, error) {
	row := q.db.QueryRow(ctx, getFiltersFromSnickers, arg.Name, arg.MinPrice, arg.MaxPrice)
	var i GetFiltersFromSnickersRow
	err := row.Scan(
		&i._35,
		&i._4,
		&i._45,
		&i._5,
		&i._55,
		&i._6,
		&i._65,
		&i._7,
		&i._75,
		&i._8,
		&i._85,
		&i._9,
		&i._95,
		&i._10,
		&i._105,
		&i._11,
		&i._115,
		&i._12,
		&i._125,
		&i._13,
		&i.Min,
		&i.Max,
		&i.FirmCountMap,
	)
	return i, err
}

const getFirms = `-- name: GetFirms :many
SELECT firm,
    array_agg(DISTINCT line) AS array_of_data
FROM "snickers"
GROUP BY firm
`

type GetFirmsRow struct {
	Firm        string      `json:"firm"`
	ArrayOfData interface{} `json:"array_of_data"`
}

func (q *Queries) GetFirms(ctx context.Context) ([]GetFirmsRow, error) {
	rows, err := q.db.Query(ctx, getFirms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFirmsRow
	for rows.Next() {
		var i GetFirmsRow
		if err := rows.Scan(&i.Firm, &i.ArrayOfData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullProductsInfoByIds = `-- name: GetFullProductsInfoByIds :many
SELECT 
    s.minprice,
    s.maxprice,
    pr.global_id,
    s.image_path,
    s.name,
    s.firm,
    d.maxdiscprice,
    s.type,
    s."3.5", s."4", s."4.5", s."5", s."5.5", 
    s."6", s."6.5", s."7", s."7.5", s."8", 
    s."8.5", s."9", s."9.5", s."10", s."10.5", 
    s."11", s."11.5", s."12", s."12.5", s."13",
    NULL::integer AS "XS",
    NULL::integer AS "S",
    NULL::integer AS "M",
    NULL::integer AS "L",
    NULL::integer AS "XL",
    NULL::integer AS "XXL"
FROM snickers s
JOIN product_registry pr ON pr.internal_id = s.id AND pr.source_table = 'snickers'
LEFT JOIN discount d ON s.id = d.productid
WHERE pr.global_id = ANY($1::integer[])

UNION ALL

SELECT 
    sm.minprice,
    sm.minprice AS maxprice,
    pr.global_id,
    sm.image_path,
    sm.name,
    sm.firm,
    d.maxdiscprice,
    sm.type,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, 
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer
FROM solomerch sm
JOIN product_registry pr ON pr.internal_id = sm.id AND pr.source_table = 'solomerch'
LEFT JOIN discount d ON sm.id = d.productid
WHERE pr.global_id = ANY($1::integer[])

UNION ALL

SELECT 
    cl.minprice,
    cl.maxprice,
    pr.global_id,
    cl.image_path,
    cl.name,
    cl.firm,
    d.maxdiscprice,
    cl.type,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer, 
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    NULL::integer, NULL::integer, NULL::integer, NULL::integer, NULL::integer,
    cl.xs::integer AS "XS",
    cl.s::integer AS "S",
    cl.m::integer AS "M",
    cl.l::integer AS "L",
    cl.xl::integer AS "XL",
    cl.xxl::integer AS "XXL"
FROM clothes cl
JOIN product_registry pr ON pr.internal_id = cl.id AND pr.source_table = 'clothes'
LEFT JOIN discount d ON cl.id = d.productid
WHERE pr.global_id = ANY($1::integer[])
ORDER BY minprice ASC
`

type GetFullProductsInfoByIdsRow struct {
	Minprice     int32       `json:"minprice"`
	Maxprice     int32       `json:"maxprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	_35          pgtype.Int4 `json:"3.5"`
	_4           pgtype.Int4 `json:"4"`
	_45          pgtype.Int4 `json:"4.5"`
	_5           pgtype.Int4 `json:"5"`
	_55          pgtype.Int4 `json:"5.5"`
	_6           pgtype.Int4 `json:"6"`
	_65          pgtype.Int4 `json:"6.5"`
	_7           pgtype.Int4 `json:"7"`
	_75          pgtype.Int4 `json:"7.5"`
	_8           pgtype.Int4 `json:"8"`
	_85          pgtype.Int4 `json:"8.5"`
	_9           pgtype.Int4 `json:"9"`
	_95          pgtype.Int4 `json:"9.5"`
	_10          pgtype.Int4 `json:"10"`
	_105         pgtype.Int4 `json:"10.5"`
	_11          pgtype.Int4 `json:"11"`
	_115         pgtype.Int4 `json:"11.5"`
	_12          pgtype.Int4 `json:"12"`
	_125         pgtype.Int4 `json:"12.5"`
	_13          pgtype.Int4 `json:"13"`
	XS           pgtype.Int4 `json:"XS"`
	S            pgtype.Int4 `json:"S"`
	M            pgtype.Int4 `json:"M"`
	L            pgtype.Int4 `json:"L"`
	XL           pgtype.Int4 `json:"XL"`
	XXL          pgtype.Int4 `json:"XXL"`
}

func (q *Queries) GetFullProductsInfoByIds(ctx context.Context, dollar_1 []int32) ([]GetFullProductsInfoByIdsRow, error) {
	rows, err := q.db.Query(ctx, getFullProductsInfoByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullProductsInfoByIdsRow
	for rows.Next() {
		var i GetFullProductsInfoByIdsRow
		if err := rows.Scan(
			&i.Minprice,
			&i.Maxprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
			&i._35,
			&i._4,
			&i._45,
			&i._5,
			&i._55,
			&i._6,
			&i._65,
			&i._7,
			&i._75,
			&i._8,
			&i._85,
			&i._9,
			&i._95,
			&i._10,
			&i._105,
			&i._11,
			&i._115,
			&i._12,
			&i._125,
			&i._13,
			&i.XS,
			&i.S,
			&i.M,
			&i.L,
			&i.XL,
			&i.XXL,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchByLineName = `-- name: GetMerchByLineName :many
SELECT name,
    image_path,
    soloMerch.id,
    value,
    article,
    type
FROM soloMerch
    LEFT JOIN discount ON soloMerch.id = productid 
WHERE firm = $1
`

type GetMerchByLineNameRow struct {
	Name      string      `json:"name"`
	ImagePath string      `json:"image_path"`
	ID        int32       `json:"id"`
	Value     []byte      `json:"value"`
	Article   pgtype.Text `json:"article"`
	Type      int32       `json:"type"`
}

func (q *Queries) GetMerchByLineName(ctx context.Context, firm string) ([]GetMerchByLineNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchByLineName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchByLineNameRow
	for rows.Next() {
		var i GetMerchByLineNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCollection = `-- name: GetMerchCollection :many
SELECT minprice, global_id, image_path, name, firm, maxdiscprice, type, total_count FROM (
    SELECT 
        COALESCE(d.minprice, s.minprice) AS minprice,
        p.global_id,
        s.image_path,
        s.name,
        s.firm,
        d.maxdiscprice,
        s.type,
        COUNT(*) OVER() AS total_count
    FROM snickers s
    JOIN product_registry p ON s.id = p.internal_id AND p.source_table = 'snickers'
    LEFT JOIN discount d ON s.id = d.productId 
    WHERE s.firm = $1 OR s.line = $2

    UNION ALL

    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        p.global_id,
        sm.image_path,
        sm.name,
        sm.firm,
        d.maxdiscprice,
        sm.type,
        COUNT(*) OVER() AS total_count
    FROM solomerch sm
    JOIN product_registry p ON sm.id = p.internal_id AND p.source_table = 'solomerch'
    LEFT JOIN discount d ON sm.id = d.productId
    WHERE sm.firm = $1 OR sm.line = $2

    UNION ALL

    SELECT 
        COALESCE(d.minprice, cl.minprice) AS minprice,
        p.global_id,
        cl.image_path,
        cl.name,
        cl.firm,
        d.maxdiscprice,
        cl.type ,
        COUNT(*) OVER() AS total_count
    FROM clothes cl
    JOIN product_registry p ON cl.id = p.internal_id AND p.source_table = 'clothes'
    LEFT JOIN discount d ON cl.id = d.productId
    WHERE cl.firm = $1 OR cl.line = $2
) AS combined_results
ORDER BY 
    CASE WHEN COALESCE(minprice, 0) > 0 THEN 0 ELSE 1 END
LIMIT $3 OFFSET $4
`

type GetMerchCollectionParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetMerchCollectionRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetMerchCollection(ctx context.Context, arg GetMerchCollectionParams) ([]GetMerchCollectionRow, error) {
	rows, err := q.db.Query(ctx, getMerchCollection,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCollectionRow
	for rows.Next() {
		var i GetMerchCollectionRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCollectionWithCount = `-- name: GetMerchCollectionWithCount :many
WITH combined_products AS (
    -- Data from snickers
    SELECT 
        COALESCE(d.minprice, s.minprice) AS minprice,
        s.id,
        s.image_path,
        s.name,
        s.firm,
        d.maxdiscprice,
        COUNT(*) OVER () AS total_count,
        s.type
    FROM snickers s
    LEFT JOIN discount d ON s.id = d.productId
    WHERE s.firm = $1 OR s.line = $2
    
    UNION ALL
    
    -- Data from solomerch
    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        sm.id,
        sm.image_path,
        sm.name,
        sm.firm,
        d.maxdiscprice,
        NULL::bigint AS total_count,
        sm.type
    FROM solomerch sm
    LEFT JOIN discount d ON sm.id = d.productId
    WHERE sm.firm = $1 OR sm.line = $2
      UNION ALL
    
    -- Data from solomerch
    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        cl.id,
        cl.image_path,
        cl.name,
        cl.firm,
        d.maxdiscprice,
        NULL::bigint AS total_count,
        cl.type 
    FROM clothes cl
    LEFT JOIN discount d ON cl.id = d.productId
    WHERE cl.firm = $1 OR cl.line = $2
)
SELECT 
    minprice,
    id,
    image_path,
    name,
    firm,
    maxdiscprice,
    type,
    FIRST_VALUE(total_count) OVER () AS total_count
FROM combined_products
ORDER BY name
LIMIT $3 OFFSET $4
`

type GetMerchCollectionWithCountParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetMerchCollectionWithCountRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	TotalCount   interface{} `json:"total_count"`
}

func (q *Queries) GetMerchCollectionWithCount(ctx context.Context, arg GetMerchCollectionWithCountParams) ([]GetMerchCollectionWithCountRow, error) {
	rows, err := q.db.Query(ctx, getMerchCollectionWithCount,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCollectionWithCountRow
	for rows.Next() {
		var i GetMerchCollectionWithCountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCountIdByName = `-- name: GetMerchCountIdByName :many
SELECT firm, SUM(count) as count
FROM (

    SELECT firm, COUNT(id) as count
    FROM snickers
    WHERE name ILIKE '%' || $1::text || '%'
    GROUP BY firm
    
    UNION ALL

    SELECT firm, COUNT(id) as count
    FROM solomerch
    WHERE name ILIKE '%' || $1::text || '%'
    GROUP BY firm
) combined_results
GROUP BY firm
ORDER BY count DESC
`

type GetMerchCountIdByNameRow struct {
	Firm  string `json:"firm"`
	Count int64  `json:"count"`
}

func (q *Queries) GetMerchCountIdByName(ctx context.Context, dollar_1 string) ([]GetMerchCountIdByNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchCountIdByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCountIdByNameRow
	for rows.Next() {
		var i GetMerchCountIdByNameRow
		if err := rows.Scan(&i.Firm, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCountOfCollectionsOrFirms = `-- name: GetMerchCountOfCollectionsOrFirms :one
SELECT 
    (SELECT COUNT(id) FROM snickers WHERE snickers.firm = $1 OR snickers.line = $2) +
     (SELECT COUNT(id) FROM clothes WHERE clothes.firm = $1 OR clothes.line = $2) +
    (SELECT COUNT(id) FROM soloMerch WHERE soloMerch.firm = $1 OR soloMerch.line = $2) AS total_count
`

type GetMerchCountOfCollectionsOrFirmsParams struct {
	Firm string `json:"firm"`
	Line string `json:"line"`
}

func (q *Queries) GetMerchCountOfCollectionsOrFirms(ctx context.Context, arg GetMerchCountOfCollectionsOrFirmsParams) (int32, error) {
	row := q.db.QueryRow(ctx, getMerchCountOfCollectionsOrFirms, arg.Firm, arg.Line)
	var total_count int32
	err := row.Scan(&total_count)
	return total_count, err
}

const getMerchFiltersByString = `-- name: GetMerchFiltersByString :one
WITH combined_products AS (
    -- Данные из snickers
  
    
    -- Данные из solomerch
    SELECT 
        sm.minprice AS minprice,
        sm.minprice AS maxprice, -- Для solomerch используем price для обоих значений
        sm.firm,
        NULL, NULL, NULL, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL
    FROM solomerch sm
    WHERE sm.name ILIKE '%' || $1::text || '%'
),
firm_counts AS (
    SELECT firm, COUNT(*) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT

    MIN(cp.minprice) AS min_price,
    MAX(cp.maxprice) AS max_price,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
`

type GetMerchFiltersByStringRow struct {
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetMerchFiltersByString(ctx context.Context, dollar_1 string) (GetMerchFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getMerchFiltersByString, dollar_1)
	var i GetMerchFiltersByStringRow
	err := row.Scan(&i.MinPrice, &i.MaxPrice, &i.FirmCountMap)
	return i, err
}

const getMerchFirms = `-- name: GetMerchFirms :many
SELECT 
    firm,
    array_agg(DISTINCT line) AS collections
FROM (
    SELECT firm, line FROM snickers WHERE line IS NOT NULL
    UNION ALL
    SELECT firm, line FROM soloMerch WHERE line IS NOT NULL
    UNION ALL
    SELECT firm, line FROM clothes WHERE line IS NOT NULL
) AS combined_products
GROUP BY firm
ORDER BY firm
`

type GetMerchFirmsRow struct {
	Firm        string      `json:"firm"`
	Collections interface{} `json:"collections"`
}

func (q *Queries) GetMerchFirms(ctx context.Context) ([]GetMerchFirmsRow, error) {
	rows, err := q.db.Query(ctx, getMerchFirms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchFirmsRow
	for rows.Next() {
		var i GetMerchFirmsRow
		if err := rows.Scan(&i.Firm, &i.Collections); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchProductsByFirmName = `-- name: GetMerchProductsByFirmName :many
(
    -- Товары из таблицы snickers
    SELECT 
        s.name,
        s.image_path,
        s.id,
        COALESCE(d.minprice, s.minprice) AS value,  -- Используем minprice как value
        s.article,
        s.type
    FROM snickers s
    LEFT JOIN discount d ON s.id = d.productid  -- Связь по snickers_id
    WHERE s.firm = $1
)
UNION ALL
(
    -- Товары из таблицы soloMerch
    SELECT 
        sm.name,
        sm.image_path,
        sm.id,
        COALESCE(d.minprice, sm.minprice) AS value,  -- Используем price как value
        sm.article,
        sm.type
    FROM solomerch sm
    LEFT JOIN discount d ON sm.id = d.productid  -- Связь по solo_merch_id
    WHERE sm.firm = $1
)
UNION ALL
(
    -- Товары из таблицы soloMerch
    SELECT 
        cl.name,
        cl.image_path,
        cl.id,
        COALESCE(d.minprice, cl.minprice) AS value,  -- Используем price как value
        cl.article,
        cl.type
    FROM clothes cl
    LEFT JOIN discount d ON cl.id = d.productid  -- Связь по solo_merch_id
    WHERE cl.firm = $1
)
ORDER BY name
`

type GetMerchProductsByFirmNameRow struct {
	Name      string      `json:"name"`
	ImagePath string      `json:"image_path"`
	ID        int32       `json:"id"`
	Value     int32       `json:"value"`
	Article   pgtype.Text `json:"article"`
	Type      int32       `json:"type"`
}

func (q *Queries) GetMerchProductsByFirmName(ctx context.Context, firm string) ([]GetMerchProductsByFirmNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchProductsByFirmName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchProductsByFirmNameRow
	for rows.Next() {
		var i GetMerchProductsByFirmNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchWithDiscount = `-- name: GetMerchWithDiscount :many
SELECT 
    s.minprice,
    s.qId,
    s.id,
    s.image_path,
    s.name,
    s.firm,
    d.maxdiscprice,
    s.type
FROM snickers s
LEFT JOIN discount d ON s.id = d.productId  -- LEFT JOIN вместо JOIN

UNION ALL

SELECT 
    sm.minprice,
    sm.qId,
    sm.id,
    sm.image_path,
    sm.name,
    sm.firm,
    d.maxdiscprice,
    sm.type
FROM solomerch sm
LEFT JOIN discount d ON sm.id = d.productId  -- LEFT JOIN вместо JOIN

UNION ALL

SELECT 
    cl.minprice,
    cl.qId,
    cl.id,
    cl.image_path,
    cl.name,
    cl.firm,
    d.maxdiscprice,
    cl.type
FROM clothes cl
LEFT JOIN discount d ON cl.id = d.productId
ORDER BY minprice ASC
`

type GetMerchWithDiscountRow struct {
	Minprice     int32       `json:"minprice"`
	Qid          string      `json:"qid"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
}

// Данные из таблицы solomerch
// Данные из таблицы clothes
func (q *Queries) GetMerchWithDiscount(ctx context.Context) ([]GetMerchWithDiscountRow, error) {
	rows, err := q.db.Query(ctx, getMerchWithDiscount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchWithDiscountRow
	for rows.Next() {
		var i GetMerchWithDiscountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.Qid,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSource = `-- name: GetProductSource :one
SELECT source_table, internal_id 
FROM product_registry 
WHERE global_id = $1
`

type GetProductSourceRow struct {
	SourceTable ProductSourceEnum `json:"source_table"`
	InternalID  int32             `json:"internal_id"`
}

func (q *Queries) GetProductSource(ctx context.Context, globalID int32) (GetProductSourceRow, error) {
	row := q.db.QueryRow(ctx, getProductSource, globalID)
	var i GetProductSourceRow
	err := row.Scan(&i.SourceTable, &i.InternalID)
	return i, err
}

const getProductsByIds = `-- name: GetProductsByIds :many
SELECT 
    s.minprice,
    pr.global_id,  -- Используем global_id вместо s.id
    s.image_path,
    s.name,
    s.firm,
    d.maxdiscprice,
    s.type
FROM snickers s
JOIN product_registry pr ON pr.internal_id = s.id AND pr.source_table = 'snickers'
LEFT JOIN discount d ON s.id = d.productId 
WHERE pr.global_id = ANY($1::integer[])

UNION ALL

SELECT 
    sm.minprice,
    pr.global_id,  -- Используем global_id вместо sm.id
    sm.image_path,
    sm.name,
    sm.firm,
    d.maxdiscprice,
    sm.type
FROM solomerch sm
JOIN product_registry pr ON pr.internal_id = sm.id AND pr.source_table = 'solomerch'
LEFT JOIN discount d ON sm.id = d.productId 
WHERE pr.global_id = ANY($1::integer[])

UNION ALL

SELECT 
    cl.minprice,
    pr.global_id,  -- Используем global_id вместо cl.id
    cl.image_path,
    cl.name,
    cl.firm,
    d.maxdiscprice,
    cl.type
FROM clothes cl
JOIN product_registry pr ON pr.internal_id = cl.id AND pr.source_table = 'clothes'
LEFT JOIN discount d ON cl.id = d.productId 
WHERE pr.global_id = ANY($1::integer[])
ORDER BY minprice ASC
`

type GetProductsByIdsRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
}

func (q *Queries) GetProductsByIds(ctx context.Context, dollar_1 []int32) ([]GetProductsByIdsRow, error) {
	rows, err := q.db.Query(ctx, getProductsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByIdsRow
	for rows.Next() {
		var i GetProductsByIdsRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByName = `-- name: GetProductsByName :many
SELECT 
    s.minprice,
    p.global_id,
    s.image_path,
    s.name,
    s.firm,
    d.maxdiscprice,
    s.type
FROM snickers s
JOIN product_registry p ON s.id = p.internal_id AND p.source_table = 'snickers'
LEFT JOIN discount d ON s.id = d.productId 
WHERE s.name ILIKE '%' || $1::text || '%'
UNION ALL
SELECT 
    sm.minprice,
    p.global_id,
    sm.image_path,
    sm.name,
    sm.firm,
    d.maxdiscprice,
    sm.type
FROM solomerch sm
   JOIN product_registry p ON sm.id = p.internal_id AND p.source_table = 'solomerch'
LEFT JOIN discount d ON sm.id = d.productId 
WHERE sm.name ILIKE '%' || $1::text || '%'
UNION ALL
SELECT 
    cl.minprice,
    p.global_id,
    cl.image_path,
    cl.name,
    cl.firm,
    d.maxdiscprice,
    cl.type
FROM clothes cl
   JOIN product_registry p ON cl.id = p.internal_id AND p.source_table = 'clothes'
LEFT JOIN discount d ON cl.id = d.productId 
WHERE cl.name ILIKE '%' || $1::text || '%'
ORDER BY minprice ASC
LIMIT $2
`

type GetProductsByNameParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

type GetProductsByNameRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
}

func (q *Queries) GetProductsByName(ctx context.Context, arg GetProductsByNameParams) ([]GetProductsByNameRow, error) {
	rows, err := q.db.Query(ctx, getProductsByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByNameRow
	for rows.Next() {
		var i GetProductsByNameRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsInfoById = `-- name: GetProductsInfoById :one
SELECT info,
    image_path,
    name,
    discount.value AS value,
    article,
    description,
    date,
    image_count
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE snickers.id = $1
`

type GetProductsInfoByIdRow struct {
	Info        []byte      `json:"info"`
	ImagePath   string      `json:"image_path"`
	Name        string      `json:"name"`
	Value       []byte      `json:"value"`
	Article     pgtype.Text `json:"article"`
	Description pgtype.Text `json:"description"`
	Date        pgtype.Text `json:"date"`
	ImageCount  int32       `json:"image_count"`
}

func (q *Queries) GetProductsInfoById(ctx context.Context, id int32) (GetProductsInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getProductsInfoById, id)
	var i GetProductsInfoByIdRow
	err := row.Scan(
		&i.Info,
		&i.ImagePath,
		&i.Name,
		&i.Value,
		&i.Article,
		&i.Description,
		&i.Date,
		&i.ImageCount,
	)
	return i, err
}

const getProductsWithDiscount = `-- name: GetProductsWithDiscount :many
SELECT 
    snickers.type,
    snickers.minPrice,
    snickers.id,
    snickers.image_path,
    snickers.name,
    snickers.firm,
    discount.maxdiscprice,
    discount.value AS discount_value
FROM snickers
JOIN discount ON snickers.id = discount.productid

UNION ALL

SELECT 
    clothes.type,
    clothes.minPrice,
    clothes.id,
    clothes.image_path,
    clothes.name,
    clothes.firm,  -- если в clothes нет firm
    discount.maxdiscprice,  -- если в clothes нет maxdiscprice
    discount.value AS discount_value
FROM clothes
JOIN discount ON clothes.id = discount.productid

UNION ALL

SELECT 
    solomerch.DeliveryType,
    solomerch.minPrice,
    solomerch.id,
    solomerch.image_path,
    solomerch.name,
    solomerch.firm,
    discount.maxdiscprice,
    discount.value AS discount_value
FROM solomerch
JOIN discount ON solomerch.id = discount.productid
`

type GetProductsWithDiscountRow struct {
	Type          int32       `json:"type"`
	Minprice      int32       `json:"minprice"`
	ID            int32       `json:"id"`
	ImagePath     string      `json:"image_path"`
	Name          string      `json:"name"`
	Firm          string      `json:"firm"`
	Maxdiscprice  pgtype.Int4 `json:"maxdiscprice"`
	DiscountValue []byte      `json:"discount_value"`
}

func (q *Queries) GetProductsWithDiscount(ctx context.Context) ([]GetProductsWithDiscountRow, error) {
	rows, err := q.db.Query(ctx, getProductsWithDiscount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsWithDiscountRow
	for rows.Next() {
		var i GetProductsWithDiscountRow
		if err := rows.Scan(
			&i.Type,
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.DiscountValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByFirmName = `-- name: GetSnickersByFirmName :many
SELECT name,
    image_path,
    snickers.id,
    value,
    article
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE firm = $1
`

type GetSnickersByFirmNameRow struct {
	Name      string      `json:"name"`
	ImagePath string      `json:"image_path"`
	ID        int32       `json:"id"`
	Value     []byte      `json:"value"`
	Article   pgtype.Text `json:"article"`
}

func (q *Queries) GetSnickersByFirmName(ctx context.Context, firm string) ([]GetSnickersByFirmNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByFirmName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByFirmNameRow
	for rows.Next() {
		var i GetSnickersByFirmNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByIds = `-- name: GetSnickersByIds :many
SELECT 
    COALESCE(d.minprice, s.minprice) AS price,
    s.id,
    s.image_path, 
    s.name, 
    s.firm, 
    d.maxdiscprice
FROM snickers s
LEFT JOIN discount d ON s.id = d.productid 
WHERE s.id = ANY($1::int[])
`

type GetSnickersByIdsRow struct {
	Price        int32       `json:"price"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
}

func (q *Queries) GetSnickersByIds(ctx context.Context, dollar_1 []int32) ([]GetSnickersByIdsRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByIdsRow
	for rows.Next() {
		var i GetSnickersByIdsRow
		if err := rows.Scan(
			&i.Price,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByLineName = `-- name: GetSnickersByLineName :many
SELECT line,
    array_agg(id) AS id,
    array_agg(image_path) AS image_path,
    array_agg(name) AS name_data
FROM snickers
WHERE line = $1
GROUP BY line
`

type GetSnickersByLineNameRow struct {
	Line      string      `json:"line"`
	ID        interface{} `json:"id"`
	ImagePath interface{} `json:"image_path"`
	NameData  interface{} `json:"name_data"`
}

func (q *Queries) GetSnickersByLineName(ctx context.Context, line string) ([]GetSnickersByLineNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByLineName, line)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByLineNameRow
	for rows.Next() {
		var i GetSnickersByLineNameRow
		if err := rows.Scan(
			&i.Line,
			&i.ID,
			&i.ImagePath,
			&i.NameData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByName = `-- name: GetSnickersByName :many
SELECT snickers.minPrice,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice,
    type
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE name ILIKE '%' || $1::text || '%'
LIMIT $2
`

type GetSnickersByNameParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

type GetSnickersByNameRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
}

func (q *Queries) GetSnickersByName(ctx context.Context, arg GetSnickersByNameParams) ([]GetSnickersByNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByNameRow
	for rows.Next() {
		var i GetSnickersByNameRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloCollection = `-- name: GetSoloCollection :many
SELECT COALESCE(discount.minprice, snickers.minprice) AS minprice,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE firm = $1
    OR line = $2
LIMIT $3 OFFSET $4
`

type GetSoloCollectionParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetSoloCollectionRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
}

func (q *Queries) GetSoloCollection(ctx context.Context, arg GetSoloCollectionParams) ([]GetSoloCollectionRow, error) {
	rows, err := q.db.Query(ctx, getSoloCollection,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoloCollectionRow
	for rows.Next() {
		var i GetSoloCollectionRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloCollectionWithCount = `-- name: GetSoloCollectionWithCount :many
SELECT COALESCE(discount.minprice, snickers.minprice) AS minprice,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice,
    COUNT(*) OVER () AS total_count
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE firm = $1
    OR line = $2
LIMIT $3 OFFSET $4
`

type GetSoloCollectionWithCountParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetSoloCollectionWithCountRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetSoloCollectionWithCount(ctx context.Context, arg GetSoloCollectionWithCountParams) ([]GetSoloCollectionWithCountRow, error) {
	rows, err := q.db.Query(ctx, getSoloCollectionWithCount,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoloCollectionWithCountRow
	for rows.Next() {
		var i GetSoloCollectionWithCountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloMerchInfoById = `-- name: GetSoloMerchInfoById :one
SELECT
    image_path,
    name,
    article,
    solomerch.minprice,
    description,
    date,
    image_count,
    discount.value AS discount_value
FROM solomerch
    LEFT JOIN discount ON solomerch.id = productid
WHERE solomerch.id = $1
`

type GetSoloMerchInfoByIdRow struct {
	ImagePath     string      `json:"image_path"`
	Name          string      `json:"name"`
	Article       pgtype.Text `json:"article"`
	Minprice      int32       `json:"minprice"`
	Description   pgtype.Text `json:"description"`
	Date          pgtype.Text `json:"date"`
	ImageCount    int32       `json:"image_count"`
	DiscountValue []byte      `json:"discount_value"`
}

func (q *Queries) GetSoloMerchInfoById(ctx context.Context, id int32) (GetSoloMerchInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getSoloMerchInfoById, id)
	var i GetSoloMerchInfoByIdRow
	err := row.Scan(
		&i.ImagePath,
		&i.Name,
		&i.Article,
		&i.Minprice,
		&i.Description,
		&i.Date,
		&i.ImageCount,
		&i.DiscountValue,
	)
	return i, err
}

const getTypeIDByCategoryAndName = `-- name: GetTypeIDByCategoryAndName :one
SELECT id 
FROM product_types
WHERE category = $1::product_source_enum 
AND enum_value = $2
`

type GetTypeIDByCategoryAndNameParams struct {
	Category ProductSourceEnum `json:"category"`
	TypeName string            `json:"type_name"`
}

func (q *Queries) GetTypeIDByCategoryAndName(ctx context.Context, arg GetTypeIDByCategoryAndNameParams) (int32, error) {
	row := q.db.QueryRow(ctx, getTypeIDByCategoryAndName, arg.Category, arg.TypeName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertDiscounts = `-- name: InsertDiscounts :one


INSERT INTO public.discount (
    productid,
    value,
    minprice,
    maxdiscprice
)
SELECT 
    unnest($1::int[]),
    unnest($2::json[]),
    NULLIF(unnest($3::int[]), 0),
    NULLIF(unnest($4::int[]), 0)
RETURNING id
`

type InsertDiscountsParams struct {
	ProductIds     []int32  `json:"product_ids"`
	DiscountValues [][]byte `json:"discount_values"`
	MinPrices      []int32  `json:"min_prices"`
	MaxDiscPrices  []int32  `json:"max_disc_prices"`
}

func (q *Queries) InsertDiscounts(ctx context.Context, arg InsertDiscountsParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertDiscounts,
		arg.ProductIds,
		arg.DiscountValues,
		arg.MinPrices,
		arg.MaxDiscPrices,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const selectMainCategories = `-- name: SelectMainCategories :one
SELECT enum_range(NULL::main_categories)
`

func (q *Queries) SelectMainCategories(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, selectMainCategories)
	var enum_range interface{}
	err := row.Scan(&enum_range)
	return enum_range, err
}
