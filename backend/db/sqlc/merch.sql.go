// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: merch.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkInsertDiscounts = `-- name: BulkInsertDiscounts :exec
INSERT INTO discount (productid, value, minprice, maxdiscprice)
SELECT 
    unnest($1::integer[]),
    unnest($2::jsonb[]),
    unnest($3::integer[]),
    unnest($4::integer[])
ON CONFLICT (productid) 
DO UPDATE SET 
    value = EXCLUDED.value,
    minprice = EXCLUDED.minprice,
    maxdiscprice = EXCLUDED.maxdiscprice,
    updated_at = NOW()
`

type BulkInsertDiscountsParams struct {
	ProductIds     []int32  `json:"product_ids"`
	DiscountValues [][]byte `json:"discount_values"`
	MinPrices      []int32  `json:"min_prices"`
	MaxDiscPrices  []int32  `json:"max_disc_prices"`
}

func (q *Queries) BulkInsertDiscounts(ctx context.Context, arg BulkInsertDiscountsParams) error {
	_, err := q.db.Exec(ctx, bulkInsertDiscounts,
		arg.ProductIds,
		arg.DiscountValues,
		arg.MinPrices,
		arg.MaxDiscPrices,
	)
	return err
}

const clearDiscounts = `-- name: ClearDiscounts :exec
DELETE FROM discount
`

func (q *Queries) ClearDiscounts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearDiscounts)
	return err
}

const getCategories = `-- name: GetCategories :many
SELECT 
    pc.name,
    pc.id,
    pc.image_path
FROM 
    product_categories pc
`

type GetCategoriesRow struct {
	Name      string      `json:"name"`
	ID        int32       `json:"id"`
	ImagePath pgtype.Text `json:"image_path"`
}

func (q *Queries) GetCategories(ctx context.Context) ([]GetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesRow
	for rows.Next() {
		var i GetCategoriesRow
		if err := rows.Scan(&i.Name, &i.ID, &i.ImagePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesWithTypes = `-- name: GetCategoriesWithTypes :many
SELECT 
    pc.id as category_id,
    pc.enum_key as category_key,
    pc.name as category_name,
    pc.image_path as image_path,
    pt.id as type_id, 
    pt.enum_key as type_key,
    pt.type_name as type_name
FROM product_categories pc
LEFT JOIN product_types pt ON pc.id = pt.category_id
ORDER BY pc.name, pt.type_name
`

type GetCategoriesWithTypesRow struct {
	CategoryID   int32       `json:"category_id"`
	CategoryKey  string      `json:"category_key"`
	CategoryName string      `json:"category_name"`
	ImagePath    pgtype.Text `json:"image_path"`
	TypeID       pgtype.Int4 `json:"type_id"`
	TypeKey      pgtype.Text `json:"type_key"`
	TypeName     pgtype.Text `json:"type_name"`
}

func (q *Queries) GetCategoriesWithTypes(ctx context.Context) ([]GetCategoriesWithTypesRow, error) {
	rows, err := q.db.Query(ctx, getCategoriesWithTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesWithTypesRow
	for rows.Next() {
		var i GetCategoriesWithTypesRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryKey,
			&i.CategoryName,
			&i.ImagePath,
			&i.TypeID,
			&i.TypeKey,
			&i.TypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCombinedFiltersByString = `-- name: GetCombinedFiltersByString :one
WITH product_data AS (
    SELECT 
        p.minprice,
        p.maxprice,
        p.firm,
        p.sizes
    FROM products p
    WHERE p.name ILIKE '%' || $1::text || '%'
),
firm_counts AS (
    SELECT firm, COUNT(*) AS firm_count
    FROM product_data
    GROUP BY firm
),
size_counts AS (
    SELECT 
        size_key,
        COUNT(*) as size_count
    FROM product_data pd
    CROSS JOIN LATERAL jsonb_object_keys(pd.sizes) as size_key
    WHERE (pd.sizes -> size_key -> 'price')::numeric > 0
    GROUP BY size_key
)
SELECT
    -- Все размеры в виде JSON объекта с количеством
    jsonb_object_agg(size_key, size_count) as sizes,
    
    -- Диапазон цен
    MIN(minprice) AS min_price,
    MAX(maxprice) AS max_price,
    
    -- Количество товаров по брендам
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM product_data pd
CROSS JOIN size_counts sc
LEFT JOIN firm_counts fc ON pd.firm = fc.firm
GROUP BY ()
`

type GetCombinedFiltersByStringRow struct {
	Sizes        []byte      `json:"sizes"`
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetCombinedFiltersByString(ctx context.Context, dollar_1 string) (GetCombinedFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getCombinedFiltersByString, dollar_1)
	var i GetCombinedFiltersByStringRow
	err := row.Scan(
		&i.Sizes,
		&i.MinPrice,
		&i.MaxPrice,
		&i.FirmCountMap,
	)
	return i, err
}

const getCountIdByName = `-- name: GetCountIdByName :many
SELECT firm,
    COUNT(id) count
FROM products
WHERE name ILIKE '%' || CAST($1 AS text) || '%'
GROUP BY $1
`

type GetCountIdByNameRow struct {
	Firm  string `json:"firm"`
	Count int64  `json:"count"`
}

func (q *Queries) GetCountIdByName(ctx context.Context, dollar_1 string) ([]GetCountIdByNameRow, error) {
	rows, err := q.db.Query(ctx, getCountIdByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountIdByNameRow
	for rows.Next() {
		var i GetCountIdByNameRow
		if err := rows.Scan(&i.Firm, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfCollectionsOrFirms = `-- name: GetCountOfCollectionsOrFirms :one
SELECT COUNT(products.id) AS count 
FROM products
WHERE firm = $1
    OR line = $2
`

type GetCountOfCollectionsOrFirmsParams struct {
	Firm string `json:"firm"`
	Line string `json:"line"`
}

func (q *Queries) GetCountOfCollectionsOrFirms(ctx context.Context, arg GetCountOfCollectionsOrFirmsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfCollectionsOrFirms, arg.Firm, arg.Line)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFiltersByNameCategoryAndType = `-- name: GetFiltersByNameCategoryAndType :one
WITH product_data AS (
    SELECT 
        p.id as global_id,
        p.firm,
        p.minprice,
        p.maxprice,
        p.sizes,
        p.bodytype,
        p.type as product_type_id
    FROM products p
    WHERE 
        ($1::int IS NULL OR p.type = $1::int) AND
         ($2::int IS NULL OR p.category = $2) AND
        ($3::text IS NULL OR p.name ILIKE '%' || $3::text || '%')
),
size_data AS (
    SELECT 
        size_key,
        COUNT(*) as count
    FROM product_data
    CROSS JOIN LATERAL jsonb_object_keys(sizes) as size_key
    WHERE (sizes -> size_key -> 'price')::numeric > 0
    GROUP BY size_key
),
firm_counts AS (
    SELECT firm, COUNT(*) AS firm_count
    FROM product_data
    GROUP BY firm
),
bodytype_counts AS (
    SELECT 
        bodytype,
        COUNT(*) as count
    FROM product_data
    GROUP BY bodytype
),
price_range AS (
    SELECT 
        COALESCE(MIN(minprice), 0) AS min_price,
        COALESCE(MAX(maxprice), 0) AS max_price
    FROM product_data
),
type_data AS (
    SELECT 
        product_type_id,
        COUNT(*) as type_count
    FROM product_data
    -- Optional: Join to a 'product_types' table to get the type name
    -- INNER JOIN product_types pt ON pt.id = product_data.product_type_id
    GROUP BY product_type_id
)
SELECT
    -- Все размеры в виде JSON объекта
    COALESCE(
        (SELECT jsonb_object_agg(size_key, count) FROM size_data),
        '{}'::jsonb
    ) as sizes,
    
    -- Статистика по типам тела
    COALESCE(
        (SELECT jsonb_object_agg(bodytype::text, count) FROM bodytype_counts),
        '{}'::jsonb
    ) as bodytypes,
    
    -- Минимальная и максимальная цена
    (SELECT min_price FROM price_range) as min_price,
    (SELECT max_price FROM price_range) as max_price,
    
    -- Статистика по брендам
    COALESCE(
        (SELECT jsonb_object_agg(COALESCE(firm, 'Unknown'), firm_count) FROM firm_counts),
        '{}'::jsonb
    ) as firms,
     COALESCE(
        (SELECT jsonb_agg(product_type_id) FROM type_data),
        '[]'::jsonb
    ) as product_types
`

type GetFiltersByNameCategoryAndTypeParams struct {
	Type     pgtype.Int4 `json:"type"`
	Category pgtype.Int4 `json:"category"`
	Name     pgtype.Text `json:"name"`
}

type GetFiltersByNameCategoryAndTypeRow struct {
	Sizes        interface{} `json:"sizes"`
	Bodytypes    interface{} `json:"bodytypes"`
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	Firms        interface{} `json:"firms"`
	ProductTypes interface{} `json:"product_types"`
}

func (q *Queries) GetFiltersByNameCategoryAndType(ctx context.Context, arg GetFiltersByNameCategoryAndTypeParams) (GetFiltersByNameCategoryAndTypeRow, error) {
	row := q.db.QueryRow(ctx, getFiltersByNameCategoryAndType, arg.Type, arg.Category, arg.Name)
	var i GetFiltersByNameCategoryAndTypeRow
	err := row.Scan(
		&i.Sizes,
		&i.Bodytypes,
		&i.MinPrice,
		&i.MaxPrice,
		&i.Firms,
		&i.ProductTypes,
	)
	return i, err
}

const getFirms = `-- name: GetFirms :many
SELECT 
    firm,
    array_agg(DISTINCT line) AS array_of_data
FROM products
GROUP BY firm
ORDER BY firm
`

type GetFirmsRow struct {
	Firm        string      `json:"firm"`
	ArrayOfData interface{} `json:"array_of_data"`
}

func (q *Queries) GetFirms(ctx context.Context) ([]GetFirmsRow, error) {
	rows, err := q.db.Query(ctx, getFirms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFirmsRow
	for rows.Next() {
		var i GetFirmsRow
		if err := rows.Scan(&i.Firm, &i.ArrayOfData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullProductsInfoByIds = `-- name: GetFullProductsInfoByIds :many
SELECT 
    p.minprice,
    p.maxprice,
    p.id as global_id,
    p.image_path,
    p.name,
    p.firm,
    d.maxdiscprice,
    p.type,
    p.sizes as sizes_jsonb  -- Все размеры в JSONB формате
FROM products p
LEFT JOIN discount d ON p.id = d.productid
WHERE p.id = ANY($1::integer[])
ORDER BY p.minprice ASC
`

type GetFullProductsInfoByIdsRow struct {
	Minprice     int32       `json:"minprice"`
	Maxprice     int32       `json:"maxprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	SizesJsonb   []byte      `json:"sizes_jsonb"`
}

func (q *Queries) GetFullProductsInfoByIds(ctx context.Context, dollar_1 []int32) ([]GetFullProductsInfoByIdsRow, error) {
	rows, err := q.db.Query(ctx, getFullProductsInfoByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullProductsInfoByIdsRow
	for rows.Next() {
		var i GetFullProductsInfoByIdsRow
		if err := rows.Scan(
			&i.Minprice,
			&i.Maxprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
			&i.SizesJsonb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMainPageInfo = `-- name: GetMainPageInfo :many
SELECT 
    p.category,
    COUNT(*) OVER (PARTITION BY p.category) as category_product_count,
    p.id,
    p.firm,
    p.name,
    p.minprice,
    p.maxprice,
    p.image_path,
    p.bodytype
FROM (
    SELECT 
        p.id,
        p.firm,
        p.name,
        p.minprice,
        p.maxprice,
        p.image_path,
        p.bodytype,
        p.category,
        ROW_NUMBER() OVER (PARTITION BY p.category ORDER BY p.id) as row_num
    FROM products p
    WHERE p.minprice IS NOT NULL AND p.minprice > 0
) p
WHERE p.row_num <= $1::int
ORDER BY p.category, p.row_num
`

type GetMainPageInfoRow struct {
	Category             int32    `json:"category"`
	CategoryProductCount int64    `json:"category_product_count"`
	ID                   int32    `json:"id"`
	Firm                 string   `json:"firm"`
	Name                 string   `json:"name"`
	Minprice             int32    `json:"minprice"`
	Maxprice             int32    `json:"maxprice"`
	ImagePath            string   `json:"image_path"`
	Bodytype             BodyEnum `json:"bodytype"`
}

func (q *Queries) GetMainPageInfo(ctx context.Context, productsPerCategory int32) ([]GetMainPageInfoRow, error) {
	rows, err := q.db.Query(ctx, getMainPageInfo, productsPerCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMainPageInfoRow
	for rows.Next() {
		var i GetMainPageInfoRow
		if err := rows.Scan(
			&i.Category,
			&i.CategoryProductCount,
			&i.ID,
			&i.Firm,
			&i.Name,
			&i.Minprice,
			&i.Maxprice,
			&i.ImagePath,
			&i.Bodytype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCollection = `-- name: GetMerchCollection :many
SELECT 
    COALESCE(d.minprice, p.minprice) AS minprice,
    p.id AS global_id,
    p.image_path,
    p.name,
    p.firm,
    d.maxdiscprice,
    st.productid,
    p.type,
    COUNT(*) OVER() AS total_count
FROM products p
LEFT JOIN discount d ON p.id = d.productid
LEFT JOIN store_house st ON p.id = st.productid
WHERE p.firm = $1 OR p.line = $2
ORDER BY 
    CASE WHEN COALESCE(COALESCE(d.minprice, p.minprice), 0) > 0 THEN 0 ELSE 1 END
LIMIT $3 OFFSET $4
`

type GetMerchCollectionParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetMerchCollectionRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Productid    pgtype.Int4 `json:"productid"`
	Type         int32       `json:"type"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetMerchCollection(ctx context.Context, arg GetMerchCollectionParams) ([]GetMerchCollectionRow, error) {
	rows, err := q.db.Query(ctx, getMerchCollection,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCollectionRow
	for rows.Next() {
		var i GetMerchCollectionRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Productid,
			&i.Type,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCollectionWithCount = `-- name: GetMerchCollectionWithCount :many
SELECT 
    COALESCE(d.minprice, p.minprice) AS minprice,
    p.id,
    p.image_path,
    p.name,
    p.firm,
    d.maxdiscprice,
    p.type,
    COUNT(*) OVER () AS total_count
FROM products p
LEFT JOIN discount d ON p.id = d.productid
WHERE p.firm = $1 OR p.line = $2
ORDER BY p.name
LIMIT $3 OFFSET $4
`

type GetMerchCollectionWithCountParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetMerchCollectionWithCountRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetMerchCollectionWithCount(ctx context.Context, arg GetMerchCollectionWithCountParams) ([]GetMerchCollectionWithCountRow, error) {
	rows, err := q.db.Query(ctx, getMerchCollectionWithCount,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCollectionWithCountRow
	for rows.Next() {
		var i GetMerchCollectionWithCountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCountOfCollectionsOrFirms = `-- name: GetMerchCountOfCollectionsOrFirms :one
SELECT COUNT(*) AS total_count
FROM products
WHERE firm = $1 OR line = $2
`

type GetMerchCountOfCollectionsOrFirmsParams struct {
	Firm string `json:"firm"`
	Line string `json:"line"`
}

func (q *Queries) GetMerchCountOfCollectionsOrFirms(ctx context.Context, arg GetMerchCountOfCollectionsOrFirmsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getMerchCountOfCollectionsOrFirms, arg.Firm, arg.Line)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getMerchFirms = `-- name: GetMerchFirms :many
SELECT 
    firm,
    array_agg(DISTINCT line) AS collections
FROM (
    SELECT firm, line FROM products WHERE line IS NOT NULL
) AS combined_products
GROUP BY firm
ORDER BY firm
`

type GetMerchFirmsRow struct {
	Firm        string      `json:"firm"`
	Collections interface{} `json:"collections"`
}

func (q *Queries) GetMerchFirms(ctx context.Context) ([]GetMerchFirmsRow, error) {
	rows, err := q.db.Query(ctx, getMerchFirms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchFirmsRow
	for rows.Next() {
		var i GetMerchFirmsRow
		if err := rows.Scan(&i.Firm, &i.Collections); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchProductsByFirmName = `-- name: GetMerchProductsByFirmName :many
SELECT 
    p.name,
    p.image_path,
    p.id,
    COALESCE(d.minprice, p.minprice) AS value,
    p.article,
    p.type
FROM products p
LEFT JOIN discount d ON p.id = d.productid
WHERE p.firm = $1
ORDER BY p.name
`

type GetMerchProductsByFirmNameRow struct {
	Name      string `json:"name"`
	ImagePath string `json:"image_path"`
	ID        int32  `json:"id"`
	Value     int32  `json:"value"`
	Article   string `json:"article"`
	Type      int32  `json:"type"`
}

func (q *Queries) GetMerchProductsByFirmName(ctx context.Context, firm string) ([]GetMerchProductsByFirmNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchProductsByFirmName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchProductsByFirmNameRow
	for rows.Next() {
		var i GetMerchProductsByFirmNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchWithDiscount = `-- name: GetMerchWithDiscount :many
SELECT 
    p.minprice,
    p.qId,
    p.id,
    p.image_path,
    p.name,
    p.firm,
    d.maxdiscprice,
    p.type
FROM products p
LEFT JOIN discount d ON p.id = d.productid
ORDER BY p.minprice ASC
`

type GetMerchWithDiscountRow struct {
	Minprice     int32       `json:"minprice"`
	Qid          string      `json:"qid"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
}

func (q *Queries) GetMerchWithDiscount(ctx context.Context) ([]GetMerchWithDiscountRow, error) {
	rows, err := q.db.Query(ctx, getMerchWithDiscount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchWithDiscountRow
	for rows.Next() {
		var i GetMerchWithDiscountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.Qid,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsBasicInfo = `-- name: GetProductsBasicInfo :many
SELECT 
    id,
    minprice,
    maxprice,
    sizes
FROM products 
WHERE id = ANY($1::int[])
`

type GetProductsBasicInfoRow struct {
	ID       int32  `json:"id"`
	Minprice int32  `json:"minprice"`
	Maxprice int32  `json:"maxprice"`
	Sizes    []byte `json:"sizes"`
}

func (q *Queries) GetProductsBasicInfo(ctx context.Context, productIds []int32) ([]GetProductsBasicInfoRow, error) {
	rows, err := q.db.Query(ctx, getProductsBasicInfo, productIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsBasicInfoRow
	for rows.Next() {
		var i GetProductsBasicInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.Minprice,
			&i.Maxprice,
			&i.Sizes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByFilters = `-- name: GetProductsByFilters :many
SELECT 
    p.id,
    p.name,
    p.image_path,
    p.firm,
    p.minprice,
    p.maxprice,
    d.maxdiscprice,
    COUNT(*) OVER() AS total_count
FROM products p
LEFT JOIN discount d ON p.id = d.productid
LEFT JOIN store_house sh ON p.id = sh.productid
WHERE 
    -- Размеры (самое сложное условие оставляем как есть)
    (COALESCE(array_length($1::text[], 1), 0) = 0 OR EXISTS (
        SELECT 1
        FROM jsonb_object_keys(p.sizes) AS size_key
        WHERE size_key = ANY($1::text[])
        AND (p.sizes -> size_key ->> 'price')::numeric > 0
    ))
     AND($2::text IS NULL OR $2::text = '' OR p.name ILIKE '%' || $2::text || '%')
    -- Простые условия для массивов
    AND (COALESCE(array_length($3::int[], 1), 0) = 0 OR p.category = ANY($3::int[]))
    AND (COALESCE(array_length($4::int[], 1), 0) = 0 OR p.type = ANY($4::int[]))
    AND (COALESCE(array_length($5::text[], 1), 0) = 0 OR p.firm = ANY($5::text[]))
    AND (COALESCE(array_length($6::text[], 1), 0) = 0 OR p.bodytype = ANY($6::body_enum[]))
    -- Условия для цен
    AND ($7::int IS NULL OR p.maxprice >= $7::int)
    AND ($8::int IS NULL OR p.minprice <= $8::int)
    AND ($9::boolean IS NULL OR $9::boolean = false OR d.id IS NOT NULL)
    AND ($10::boolean IS NULL OR $10::boolean = false OR (sh.id IS NOT NULL AND sh.quantity > 0))
    AND ($11::boolean IS NULL OR $11::boolean = false OR  p.minprice > 0)

ORDER BY 
    CASE WHEN $12::int = 1 THEN p.name END ASC,
    CASE WHEN $12::int = 2 THEN p.name END DESC,
    
    -- Сортировка по цене
    CASE WHEN $12::int = 3 THEN p.minprice END ASC,
    CASE WHEN $12::int = 4 THEN p.minprice END DESC,
    
    -- Сортировка по умолчанию
    CASE WHEN $12::int NOT IN (1,2,3,4) THEN p.name END ASC,
    -- Стабильная сортировка
    p.id ASC
LIMIT CASE WHEN $14::integer > 0 THEN $14::integer ELSE 50 END
OFFSET CASE WHEN $13::integer > 0 THEN $13::integer ELSE 0 END
`

type GetProductsByFiltersParams struct {
	Sizes        []string    `json:"sizes"`
	Name         string      `json:"name"`
	Categories   []int32     `json:"categories"`
	ProductTypes []int32     `json:"product_types"`
	Firms        []string    `json:"firms"`
	Bodytypes    []string    `json:"bodytypes"`
	Minprice     pgtype.Int4 `json:"minprice"`
	Maxprice     pgtype.Int4 `json:"maxprice"`
	HasDiscount  bool        `json:"has_discount"`
	InStore      bool        `json:"in_store"`
	WithPrice    bool        `json:"with_price"`
	SortType     int32       `json:"sort_type"`
	Offsetval    int32       `json:"offsetval"`
	Limitval     int32       `json:"limitval"`
}

type GetProductsByFiltersRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	ImagePath    string      `json:"image_path"`
	Firm         string      `json:"firm"`
	Minprice     int32       `json:"minprice"`
	Maxprice     int32       `json:"maxprice"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetProductsByFilters(ctx context.Context, arg GetProductsByFiltersParams) ([]GetProductsByFiltersRow, error) {
	rows, err := q.db.Query(ctx, getProductsByFilters,
		arg.Sizes,
		arg.Name,
		arg.Categories,
		arg.ProductTypes,
		arg.Firms,
		arg.Bodytypes,
		arg.Minprice,
		arg.Maxprice,
		arg.HasDiscount,
		arg.InStore,
		arg.WithPrice,
		arg.SortType,
		arg.Offsetval,
		arg.Limitval,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByFiltersRow
	for rows.Next() {
		var i GetProductsByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImagePath,
			&i.Firm,
			&i.Minprice,
			&i.Maxprice,
			&i.Maxdiscprice,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByFiltersNewTest = `-- name: GetProductsByFiltersNewTest :many
SELECT 
    p.id,
    p.name,
    d.maxdiscprice,
    p.image_path
FROM products p
LEFT JOIN discount d ON p.id = d.productid
WHERE 
    -- Размеры (самое сложное условие оставляем как есть)
    (COALESCE(array_length($1::text[], 1), 0) = 0 OR EXISTS (
        SELECT 1
        FROM jsonb_object_keys(p.sizes) AS size_key
        WHERE size_key = ANY($1::text[])
        AND (p.sizes -> size_key ->> 'price')::numeric > 0
    ))
    AND($2::text IS NULL OR $2::text = '' OR p.name ILIKE '%' || $2::text || '%')
    -- Простые условия для массивов
    AND (COALESCE(array_length($3::int[], 1), 0) = 0 OR p.category = ANY($3::int[]))
    AND (COALESCE(array_length($4::int[], 1), 0) = 0 OR p.type = ANY($4::int[]))
    AND (COALESCE(array_length($5::text[], 1), 0) = 0 OR p.firm = ANY($5::text[]))
    AND (COALESCE(array_length($6::text[], 1), 0) = 0 OR p.bodytype = ANY($6::body_enum[]))
    -- Условия для цен
    AND ($7::int IS NULL OR p.minprice >= $7::int)
    AND ($8::int IS NULL OR p.maxprice <= $8::int)
`

type GetProductsByFiltersNewTestParams struct {
	Sizes        []string    `json:"sizes"`
	Name         string      `json:"name"`
	Categories   []int32     `json:"categories"`
	ProductTypes []int32     `json:"product_types"`
	Firms        []string    `json:"firms"`
	Bodytypes    []string    `json:"bodytypes"`
	Minprice     pgtype.Int4 `json:"minprice"`
	Maxprice     pgtype.Int4 `json:"maxprice"`
}

type GetProductsByFiltersNewTestRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	ImagePath    string      `json:"image_path"`
}

func (q *Queries) GetProductsByFiltersNewTest(ctx context.Context, arg GetProductsByFiltersNewTestParams) ([]GetProductsByFiltersNewTestRow, error) {
	rows, err := q.db.Query(ctx, getProductsByFiltersNewTest,
		arg.Sizes,
		arg.Name,
		arg.Categories,
		arg.ProductTypes,
		arg.Firms,
		arg.Bodytypes,
		arg.Minprice,
		arg.Maxprice,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByFiltersNewTestRow
	for rows.Next() {
		var i GetProductsByFiltersNewTestRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Maxdiscprice,
			&i.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByIds = `-- name: GetProductsByIds :many
SELECT 
    p.minprice,
    p.id as global_id,  -- Теперь id products это global_id
    p.image_path,
    p.name,
    p.firm,
    d.maxdiscprice,
    p.type,
    p.article
FROM products p
LEFT JOIN discount d ON p.id = d.productid 
WHERE p.id = ANY($1::integer[])
ORDER BY p.minprice ASC
`

type GetProductsByIdsRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	Article      string      `json:"article"`
}

func (q *Queries) GetProductsByIds(ctx context.Context, dollar_1 []int32) ([]GetProductsByIdsRow, error) {
	rows, err := q.db.Query(ctx, getProductsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByIdsRow
	for rows.Next() {
		var i GetProductsByIdsRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Type,
			&i.Article,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByLineName = `-- name: GetProductsByLineName :many
SELECT line,
    array_agg(id) AS id,
    array_agg(image_path) AS image_path,
    array_agg(name) AS name_data
FROM products
WHERE line = $1
GROUP BY line
`

type GetProductsByLineNameRow struct {
	Line      string      `json:"line"`
	ID        interface{} `json:"id"`
	ImagePath interface{} `json:"image_path"`
	NameData  interface{} `json:"name_data"`
}

func (q *Queries) GetProductsByLineName(ctx context.Context, line string) ([]GetProductsByLineNameRow, error) {
	rows, err := q.db.Query(ctx, getProductsByLineName, line)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByLineNameRow
	for rows.Next() {
		var i GetProductsByLineNameRow
		if err := rows.Scan(
			&i.Line,
			&i.ID,
			&i.ImagePath,
			&i.NameData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByName = `-- name: GetProductsByName :many
SELECT 
    p.id as global_id,
    p.image_path,
    p.name,
    p.firm,
    p.minprice,
    p.maxprice,
    d.maxdiscprice,
    p.type,
    p.article,
    p.type,
    p.category
FROM products p
LEFT JOIN discount d ON p.id = d.productid 
WHERE p.name ILIKE '%' || $1::text || '%'
ORDER BY 
    CASE WHEN COALESCE(p.minprice, 0) > 0 THEN 0 ELSE 1 END,
    p.name
LIMIT $2
`

type GetProductsByNameParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

type GetProductsByNameRow struct {
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Minprice     int32       `json:"minprice"`
	Maxprice     int32       `json:"maxprice"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Type         int32       `json:"type"`
	Article      string      `json:"article"`
	Type_2       int32       `json:"type_2"`
	Category     int32       `json:"category"`
}

func (q *Queries) GetProductsByName(ctx context.Context, arg GetProductsByNameParams) ([]GetProductsByNameRow, error) {
	rows, err := q.db.Query(ctx, getProductsByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByNameRow
	for rows.Next() {
		var i GetProductsByNameRow
		if err := rows.Scan(
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Minprice,
			&i.Maxprice,
			&i.Maxdiscprice,
			&i.Type,
			&i.Article,
			&i.Type_2,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByNameCategoryAndType = `-- name: GetProductsByNameCategoryAndType :many
 SELECT 
        p.id as global_id,
        p.firm,
        p.minprice,
        p.maxprice,
        p.sizes,
        p.bodytype
    FROM products p
    WHERE 
        ($1::int IS NULL OR p.type = $1::int) AND
         ($2::int IS NULL OR p.category = $2) AND
        ($3::text IS NULL OR p.name ILIKE '%' || $3::text || '%')
`

type GetProductsByNameCategoryAndTypeParams struct {
	Type     pgtype.Int4 `json:"type"`
	Category pgtype.Int4 `json:"category"`
	Name     pgtype.Text `json:"name"`
}

type GetProductsByNameCategoryAndTypeRow struct {
	GlobalID int32    `json:"global_id"`
	Firm     string   `json:"firm"`
	Minprice int32    `json:"minprice"`
	Maxprice int32    `json:"maxprice"`
	Sizes    []byte   `json:"sizes"`
	Bodytype BodyEnum `json:"bodytype"`
}

func (q *Queries) GetProductsByNameCategoryAndType(ctx context.Context, arg GetProductsByNameCategoryAndTypeParams) ([]GetProductsByNameCategoryAndTypeRow, error) {
	rows, err := q.db.Query(ctx, getProductsByNameCategoryAndType, arg.Type, arg.Category, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByNameCategoryAndTypeRow
	for rows.Next() {
		var i GetProductsByNameCategoryAndTypeRow
		if err := rows.Scan(
			&i.GlobalID,
			&i.Firm,
			&i.Minprice,
			&i.Maxprice,
			&i.Sizes,
			&i.Bodytype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsInfoById = `-- name: GetProductsInfoById :one
SELECT sizes,
    image_path,
    name,
    discount.value AS value,
    COALESCE(
        jsonb_object_agg(st.size, st.quantity) FILTER (WHERE st.size IS NOT NULL),
        '{}'::jsonb
    ) as store_info,
    article,
    description,
    line,
    type,
    date,
    firm,
    image_count
FROM products
    LEFT JOIN discount ON products.id = productid
    LEFT JOIN store_house st ON products.id = st.productid
WHERE products.id = $1
GROUP BY products.id, discount.value
`

type GetProductsInfoByIdRow struct {
	Sizes       []byte      `json:"sizes"`
	ImagePath   string      `json:"image_path"`
	Name        string      `json:"name"`
	Value       []byte      `json:"value"`
	StoreInfo   interface{} `json:"store_info"`
	Article     string      `json:"article"`
	Description pgtype.Text `json:"description"`
	Line        string      `json:"line"`
	Type        int32       `json:"type"`
	Date        pgtype.Text `json:"date"`
	Firm        string      `json:"firm"`
	ImageCount  int32       `json:"image_count"`
}

func (q *Queries) GetProductsInfoById(ctx context.Context, id int32) (GetProductsInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getProductsInfoById, id)
	var i GetProductsInfoByIdRow
	err := row.Scan(
		&i.Sizes,
		&i.ImagePath,
		&i.Name,
		&i.Value,
		&i.StoreInfo,
		&i.Article,
		&i.Description,
		&i.Line,
		&i.Type,
		&i.Date,
		&i.Firm,
		&i.ImageCount,
	)
	return i, err
}

const getProductsWithDiscount = `-- name: GetProductsWithDiscount :many
SELECT 
    p.type,
    p.minprice,
    p.id,
    p.image_path,
    p.name,
    p.firm,
    d.maxdiscprice,          -- из таблицы discount
    d.value AS discount_value -- из таблицы discount
FROM products p
JOIN discount d ON p.id = d.productid
`

type GetProductsWithDiscountRow struct {
	Type          int32       `json:"type"`
	Minprice      int32       `json:"minprice"`
	ID            int32       `json:"id"`
	ImagePath     string      `json:"image_path"`
	Name          string      `json:"name"`
	Firm          string      `json:"firm"`
	Maxdiscprice  pgtype.Int4 `json:"maxdiscprice"`
	DiscountValue []byte      `json:"discount_value"`
}

func (q *Queries) GetProductsWithDiscount(ctx context.Context) ([]GetProductsWithDiscountRow, error) {
	rows, err := q.db.Query(ctx, getProductsWithDiscount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsWithDiscountRow
	for rows.Next() {
		var i GetProductsWithDiscountRow
		if err := rows.Scan(
			&i.Type,
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.DiscountValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByFirmName = `-- name: GetSnickersByFirmName :many
SELECT name,
    image_path,
    products.id,
    value,
    article
FROM    products
    LEFT JOIN discount ON products.id = productid
WHERE firm = $1
`

type GetSnickersByFirmNameRow struct {
	Name      string `json:"name"`
	ImagePath string `json:"image_path"`
	ID        int32  `json:"id"`
	Value     []byte `json:"value"`
	Article   string `json:"article"`
}

func (q *Queries) GetSnickersByFirmName(ctx context.Context, firm string) ([]GetSnickersByFirmNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByFirmName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByFirmNameRow
	for rows.Next() {
		var i GetSnickersByFirmNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloCollection = `-- name: GetSoloCollection :many
SELECT COALESCE(discount.minprice, products.minprice) AS minprice,
    products.id,
    image_path,
    name,
    firm,
    maxdiscprice
FROM products
    LEFT JOIN discount ON products.id = productid
WHERE firm = $1
    OR line = $2
LIMIT $3 OFFSET $4
`

type GetSoloCollectionParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetSoloCollectionRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
}

func (q *Queries) GetSoloCollection(ctx context.Context, arg GetSoloCollectionParams) ([]GetSoloCollectionRow, error) {
	rows, err := q.db.Query(ctx, getSoloCollection,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoloCollectionRow
	for rows.Next() {
		var i GetSoloCollectionRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloCollectionWithCount = `-- name: GetSoloCollectionWithCount :many
SELECT COALESCE(discount.minprice, products.minprice) AS minprice,
    products.id,
    image_path,
    name,
    firm,
    maxdiscprice,
    COUNT(*) OVER () AS total_count
FROM products
    LEFT JOIN discount ON products.id = productid
WHERE firm = $1
    OR line = $2
LIMIT $3 OFFSET $4
`

type GetSoloCollectionWithCountParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetSoloCollectionWithCountRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetSoloCollectionWithCount(ctx context.Context, arg GetSoloCollectionWithCountParams) ([]GetSoloCollectionWithCountRow, error) {
	rows, err := q.db.Query(ctx, getSoloCollectionWithCount,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoloCollectionWithCountRow
	for rows.Next() {
		var i GetSoloCollectionWithCountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDiscounts = `-- name: InsertDiscounts :one
INSERT INTO public.discount (
    productid,
    value,
    minprice,
    maxdiscprice
)
SELECT 
    unnest($1::int[]),
    unnest($2::json[]),
    NULLIF(unnest($3::int[]), 0),
    NULLIF(unnest($4::int[]), 0)
RETURNING id
`

type InsertDiscountsParams struct {
	ProductIds     []int32  `json:"product_ids"`
	DiscountValues [][]byte `json:"discount_values"`
	MinPrices      []int32  `json:"min_prices"`
	MaxDiscPrices  []int32  `json:"max_disc_prices"`
}

func (q *Queries) InsertDiscounts(ctx context.Context, arg InsertDiscountsParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertDiscounts,
		arg.ProductIds,
		arg.DiscountValues,
		arg.MinPrices,
		arg.MaxDiscPrices,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const selectMainCategories = `-- name: SelectMainCategories :one
SELECT enum_range(NULL::main_categories)
`

func (q *Queries) SelectMainCategories(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, selectMainCategories)
	var enum_range interface{}
	err := row.Scan(&enum_range)
	return enum_range, err
}
