// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: merch.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getClothesInfoById = `-- name: GetClothesInfoById :one
SELECT
    image_path,
    name,
    article,
    clothes.minprice,
    description,
    date,
    image_count
FROM clothes
    LEFT JOIN discount ON clothes.id = productid
WHERE clothes.id = $1
`

type GetClothesInfoByIdRow struct {
	ImagePath   string      `json:"image_path"`
	Name        string      `json:"name"`
	Article     pgtype.Text `json:"article"`
	Minprice    int32       `json:"minprice"`
	Description pgtype.Text `json:"description"`
	Date        pgtype.Text `json:"date"`
	ImageCount  int32       `json:"image_count"`
}

func (q *Queries) GetClothesInfoById(ctx context.Context, id int32) (GetClothesInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getClothesInfoById, id)
	var i GetClothesInfoByIdRow
	err := row.Scan(
		&i.ImagePath,
		&i.Name,
		&i.Article,
		&i.Minprice,
		&i.Description,
		&i.Date,
		&i.ImageCount,
	)
	return i, err
}

const getCombinedFiltersByString = `-- name: GetCombinedFiltersByString :one
WITH combined_products AS (
    -- Data from snickers (only shoe sizes)
    SELECT 
        s.minprice AS minprice,
        s.maxprice AS maxprice,
        s.firm,
        s."3.5", s."4", s."4.5", s."5", s."5.5", 
        s."6", s."6.5", s."7", s."7.5", s."8", 
        s."8.5", s."9", s."9.5", s."10", s."10.5", 
        s."11", s."11.5", s."12", s."12.5", s."13",
        NULL AS "XS", -- These will always be NULL for snickers
        NULL AS "S",
        NULL AS "M",
        NULL AS "L",
        NULL AS "XL",
        NULL AS "XXL"
    FROM snickers s
    WHERE s.name ILIKE '%' || $1::text || '%'
    
    UNION ALL
    
    -- Data from solomerch (no size columns)
    SELECT 
        sm.minprice AS minprice,
        sm.maxprice AS maxprice,
        sm.firm,
        NULL, NULL, NULL, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL
    FROM solomerch sm
    WHERE sm.name ILIKE '%' || $1::text || '%'
    
    UNION ALL
    
    -- Data from clothes (only clothing sizes)
    SELECT 
        cl.minprice AS minprice,
        cl.maxprice AS maxprice,
        cl.firm,
        NULL, NULL, NULL, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        cl."XS",
        cl."S",
        cl."M",
        cl."L",
        cl."XL",
        cl."XXL"
    FROM clothes cl
    WHERE cl.name ILIKE '%' || $1::text || '%'
),
firm_counts AS (
    SELECT firm, COUNT(*) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT
    -- Shoe sizes (only from snickers)
    COUNT(NULLIF(cp."3.5", 0)) AS "3.5",
    COUNT(NULLIF(cp."4", 0)) AS "4",
    COUNT(NULLIF(cp."4.5", 0)) AS "4.5",
    COUNT(NULLIF(cp."5", 0)) AS "5",
    COUNT(NULLIF(cp."5.5", 0)) AS "5.5",
    COUNT(NULLIF(cp."6", 0)) AS "6",
    COUNT(NULLIF(cp."6.5", 0)) AS "6.5",
    COUNT(NULLIF(cp."7", 0)) AS "7",
    COUNT(NULLIF(cp."7.5", 0)) AS "7.5",
    COUNT(NULLIF(cp."8", 0)) AS "8",
    COUNT(NULLIF(cp."8.5", 0)) AS "8.5",
    COUNT(NULLIF(cp."9", 0)) AS "9",
    COUNT(NULLIF(cp."9.5", 0)) AS "9.5",
    COUNT(NULLIF(cp."10", 0)) AS "10",
    COUNT(NULLIF(cp."10.5", 0)) AS "10.5",
    COUNT(NULLIF(cp."11", 0)) AS "11",
    COUNT(NULLIF(cp."11.5", 0)) AS "11.5",
    COUNT(NULLIF(cp."12", 0)) AS "12",
    COUNT(NULLIF(cp."12.5", 0)) AS "12.5",
    COUNT(NULLIF(cp."13", 0)) AS "13",
    
    -- Clothing sizes (only from clothes)
    COUNT(NULLIF(cp."XS", 0)) AS "XS",
    COUNT(NULLIF(cp."S", 0)) AS "S",
    COUNT(NULLIF(cp."M", 0)) AS "M",
    COUNT(NULLIF(cp."L", 0)) AS "L",
    COUNT(NULLIF(cp."XL", 0)) AS "XL",
    COUNT(NULLIF(cp."XXL", 0)) AS "XXL",
    
    -- Price ranges
    MIN(cp.minprice) AS min_price,
    MAX(cp.maxprice) AS max_price,
    
    -- Firm counts
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) FILTER (WHERE fc.firm IS NOT NULL) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
GROUP BY 1
`

type GetCombinedFiltersByStringRow struct {
	_35          int64       `json:"3.5"`
	_4           int64       `json:"4"`
	_45          int64       `json:"4.5"`
	_5           int64       `json:"5"`
	_55          int64       `json:"5.5"`
	_6           int64       `json:"6"`
	_65          int64       `json:"6.5"`
	_7           int64       `json:"7"`
	_75          int64       `json:"7.5"`
	_8           int64       `json:"8"`
	_85          int64       `json:"8.5"`
	_9           int64       `json:"9"`
	_95          int64       `json:"9.5"`
	_10          int64       `json:"10"`
	_105         int64       `json:"10.5"`
	_11          int64       `json:"11"`
	_115         int64       `json:"11.5"`
	_12          int64       `json:"12"`
	_125         int64       `json:"12.5"`
	_13          int64       `json:"13"`
	XS           int64       `json:"XS"`
	S            int64       `json:"S"`
	M            int64       `json:"M"`
	L            int64       `json:"L"`
	XL           int64       `json:"XL"`
	XXL          int64       `json:"XXL"`
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetCombinedFiltersByString(ctx context.Context, dollar_1 string) (GetCombinedFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getCombinedFiltersByString, dollar_1)
	var i GetCombinedFiltersByStringRow
	err := row.Scan(
		&i._35,
		&i._4,
		&i._45,
		&i._5,
		&i._55,
		&i._6,
		&i._65,
		&i._7,
		&i._75,
		&i._8,
		&i._85,
		&i._9,
		&i._95,
		&i._10,
		&i._105,
		&i._11,
		&i._115,
		&i._12,
		&i._125,
		&i._13,
		&i.XS,
		&i.S,
		&i.M,
		&i.L,
		&i.XL,
		&i.XXL,
		&i.MinPrice,
		&i.MaxPrice,
		&i.FirmCountMap,
	)
	return i, err
}

const getCountIdByName = `-- name: GetCountIdByName :many
SELECT firm,
    COUNT(id) count
FROM snickers
WHERE name ILIKE '%' || CAST($1 AS text) || '%'
GROUP BY $1
`

type GetCountIdByNameRow struct {
	Firm  string `json:"firm"`
	Count int64  `json:"count"`
}

func (q *Queries) GetCountIdByName(ctx context.Context, dollar_1 string) ([]GetCountIdByNameRow, error) {
	rows, err := q.db.Query(ctx, getCountIdByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountIdByNameRow
	for rows.Next() {
		var i GetCountIdByNameRow
		if err := rows.Scan(&i.Firm, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountOfCollectionsOrFirms = `-- name: GetCountOfCollectionsOrFirms :one
SELECT COUNT(snickers.id) AS count 
FROM snickers
WHERE firm = $1
    OR line = $2
`

type GetCountOfCollectionsOrFirmsParams struct {
	Firm string `json:"firm"`
	Line string `json:"line"`
}

func (q *Queries) GetCountOfCollectionsOrFirms(ctx context.Context, arg GetCountOfCollectionsOrFirmsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfCollectionsOrFirms, arg.Firm, arg.Line)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFiltersByString = `-- name: GetFiltersByString :one
WITH firm_counts AS (
    SELECT s.firm, COUNT(s.id) AS firm_count
    FROM snickers AS s
    WHERE s.name ILIKE '%' || $1::text || '%'
    GROUP BY s.firm
)
SELECT
    COUNT(s."3.5") AS "3.5",
    COUNT(s."4") AS "4",
    COUNT(s."4.5") AS "4.5",
    COUNT(s."5") AS "5",
    COUNT(s."5.5") AS "5.5",
    COUNT(s."6") AS "6",
    COUNT(s."6.5") AS "6.5",
    COUNT(s."7") AS "7",
    COUNT(s."7.5") AS "7.5",
    COUNT(s."8") AS "8",
    COUNT(s."8.5") AS "8.5",
    COUNT(s."9") AS "9",
    COUNT(s."9.5") AS "9.5",
    COUNT(s."10") AS "10",
    COUNT(s."10.5") AS "10.5",
    COUNT(s."11") AS "11",
    COUNT(s."11.5") AS "11.5",
    COUNT(s."12") AS "12",
    COUNT(s."12.5") AS "12.5",
    COUNT(s."13") AS "13",
    MIN(s.minprice) AS min,
    MAX(s.maxprice) AS max,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM snickers AS s
LEFT JOIN firm_counts fc ON s.firm = fc.firm
WHERE s.name ILIKE '%' || $1::text || '%'
`

type GetFiltersByStringRow struct {
	_35          int64       `json:"3.5"`
	_4           int64       `json:"4"`
	_45          int64       `json:"4.5"`
	_5           int64       `json:"5"`
	_55          int64       `json:"5.5"`
	_6           int64       `json:"6"`
	_65          int64       `json:"6.5"`
	_7           int64       `json:"7"`
	_75          int64       `json:"7.5"`
	_8           int64       `json:"8"`
	_85          int64       `json:"8.5"`
	_9           int64       `json:"9"`
	_95          int64       `json:"9.5"`
	_10          int64       `json:"10"`
	_105         int64       `json:"10.5"`
	_11          int64       `json:"11"`
	_115         int64       `json:"11.5"`
	_12          int64       `json:"12"`
	_125         int64       `json:"12.5"`
	_13          int64       `json:"13"`
	Min          interface{} `json:"min"`
	Max          interface{} `json:"max"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetFiltersByString(ctx context.Context, dollar_1 string) (GetFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getFiltersByString, dollar_1)
	var i GetFiltersByStringRow
	err := row.Scan(
		&i._35,
		&i._4,
		&i._45,
		&i._5,
		&i._55,
		&i._6,
		&i._65,
		&i._7,
		&i._75,
		&i._8,
		&i._85,
		&i._9,
		&i._95,
		&i._10,
		&i._105,
		&i._11,
		&i._115,
		&i._12,
		&i._125,
		&i._13,
		&i.Min,
		&i.Max,
		&i.FirmCountMap,
	)
	return i, err
}

const getFirms = `-- name: GetFirms :many
SELECT firm,
    array_agg(DISTINCT line) AS array_of_data
FROM "snickers"
GROUP BY firm
`

type GetFirmsRow struct {
	Firm        string      `json:"firm"`
	ArrayOfData interface{} `json:"array_of_data"`
}

func (q *Queries) GetFirms(ctx context.Context) ([]GetFirmsRow, error) {
	rows, err := q.db.Query(ctx, getFirms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFirmsRow
	for rows.Next() {
		var i GetFirmsRow
		if err := rows.Scan(&i.Firm, &i.ArrayOfData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchByIds = `-- name: GetMerchByIds :many
SELECT 
    s.minPrice,
    s.id,
    s.image_path,
    s.name,
    s.firm,
    d.maxdiscprice,
    'snickers' AS producttype
FROM snickers s
LEFT JOIN discount d ON s.id = d.productId 
WHERE s.id = ANY($1::integer[])

UNION ALL

SELECT 
    sm.minprice,
    sm.id,
    sm.image_path,
    sm.name,
    sm.firm,
    d.maxdiscprice,
    'solomerch' AS producttype
FROM solomerch sm
LEFT JOIN discount d ON sm.id = d.productId 
WHERE sm.id = ANY($1::integer[])
`

type GetMerchByIdsRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Producttype  string      `json:"producttype"`
}

func (q *Queries) GetMerchByIds(ctx context.Context, dollar_1 []int32) ([]GetMerchByIdsRow, error) {
	rows, err := q.db.Query(ctx, getMerchByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchByIdsRow
	for rows.Next() {
		var i GetMerchByIdsRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchByLineName = `-- name: GetMerchByLineName :many


SELECT name,
    image_path,
    soloMerch.id,
    value,
    article,
     'solomerch' AS producttype
FROM soloMerch
    LEFT JOIN discount ON soloMerch.id = productid 
WHERE firm = $1
`

type GetMerchByLineNameRow struct {
	Name        string      `json:"name"`
	ImagePath   string      `json:"image_path"`
	ID          int32       `json:"id"`
	Value       []byte      `json:"value"`
	Article     pgtype.Text `json:"article"`
	Producttype string      `json:"producttype"`
}

func (q *Queries) GetMerchByLineName(ctx context.Context, firm string) ([]GetMerchByLineNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchByLineName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchByLineNameRow
	for rows.Next() {
		var i GetMerchByLineNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchByName = `-- name: GetMerchByName :many
SELECT 
    s.minPrice,
    p.global_id,
    s.image_path,
    s.name,
    s.firm,
    d.maxdiscprice,
    'snickers' AS producttype
FROM snickers s
JOIN product_registry p ON s.id = p.internal_id AND p.source_table = 'snickers'
LEFT JOIN discount d ON s.id = d.productId 
WHERE s.name ILIKE '%' || $1::text || '%'
UNION ALL
SELECT 
    sm.minprice,
    p.global_id,
    sm.image_path,
    sm.name,
    sm.firm,
    d.maxdiscprice,
    'solomerch' AS producttype
FROM solomerch sm
   JOIN product_registry p ON sm.id = p.internal_id AND p.source_table = 'solomerch'
LEFT JOIN discount d ON sm.id = d.productId 
WHERE sm.name ILIKE '%' || $1::text || '%'
UNION ALL
SELECT 
    cl.minprice,
    p.global_id,
    cl.image_path,
    cl.name,
    cl.firm,
    d.maxdiscprice,
    'clothes' AS producttype
FROM clothes cl
   JOIN product_registry p ON cl.id = p.internal_id AND p.source_table = 'solomerch'
LEFT JOIN discount d ON cl.id = d.productId 
WHERE cl.name ILIKE '%' || $1::text || '%'
LIMIT $2
`

type GetMerchByNameParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

type GetMerchByNameRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Producttype  string      `json:"producttype"`
}

func (q *Queries) GetMerchByName(ctx context.Context, arg GetMerchByNameParams) ([]GetMerchByNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchByNameRow
	for rows.Next() {
		var i GetMerchByNameRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCollection = `-- name: GetMerchCollection :many
(
    SELECT 
        COALESCE(d.minprice, s.minprice) AS minprice,
        p.global_id,
        s.image_path,
        s.name,
        s.firm,
        d.maxdiscprice,
        'snickers' AS producttype
    FROM snickers s
    JOIN product_registry p ON s.id = p.internal_id AND p.source_table = 'snickers'
    LEFT JOIN discount d ON s.id = d.productId 
    WHERE s.firm = $1 OR s.line = $2
    ORDER BY s.id
)
UNION ALL
(
    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        p.global_id,
        sm.image_path,
        sm.name,
        sm.firm,
        d.maxdiscprice,
        'solomerch' AS producttype
    FROM solomerch sm
     JOIN product_registry p ON sm.id = p.internal_id AND p.source_table = 'solomerch'
    LEFT JOIN discount d ON sm.id = d.productId
    WHERE sm.firm = $1 OR sm.line = $2
    ORDER BY sm.id
)
UNION ALL
(
    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        p.global_id,
        cl.image_path,
        cl.name,
        cl.firm,
        d.maxdiscprice,
        'clothes' AS producttype
    FROM clothes cl
     JOIN product_registry p ON cl.id = p.internal_id AND p.source_table = 'clothes'
    LEFT JOIN discount d ON cl.id = d.productId
    WHERE cl.firm = $1 OR cl.line = $2
    ORDER BY cl.id
)
LIMIT $3 OFFSET $4
`

type GetMerchCollectionParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetMerchCollectionRow struct {
	Minprice     int32       `json:"minprice"`
	GlobalID     int32       `json:"global_id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Producttype  string      `json:"producttype"`
}

func (q *Queries) GetMerchCollection(ctx context.Context, arg GetMerchCollectionParams) ([]GetMerchCollectionRow, error) {
	rows, err := q.db.Query(ctx, getMerchCollection,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCollectionRow
	for rows.Next() {
		var i GetMerchCollectionRow
		if err := rows.Scan(
			&i.Minprice,
			&i.GlobalID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCollectionWithCount = `-- name: GetMerchCollectionWithCount :many
WITH combined_products AS (
    -- Data from snickers
    SELECT 
        COALESCE(d.minprice, s.minprice) AS minprice,
        s.id,
        s.image_path,
        s.name,
        s.firm,
        d.maxdiscprice,
        COUNT(*) OVER () AS total_count,
        'snickers' AS producttype
    FROM snickers s
    LEFT JOIN discount d ON s.id = d.productId
    WHERE s.firm = $1 OR s.line = $2
    
    UNION ALL
    
    -- Data from solomerch
    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        sm.id,
        sm.image_path,
        sm.name,
        sm.firm,
        d.maxdiscprice,
        NULL::bigint AS total_count,
        'solomerch' AS producttype
    FROM solomerch sm
    LEFT JOIN discount d ON sm.id = d.productId
    WHERE sm.firm = $1 OR sm.line = $2
      UNION ALL
    
    -- Data from solomerch
    SELECT 
        COALESCE(d.minprice, sm.minprice) AS minprice,
        cl.id,
        cl.image_path,
        cl.name,
        cl.firm,
        d.maxdiscprice,
        NULL::bigint AS total_count,
        'clothes' AS producttype
    FROM clothes cl
    LEFT JOIN discount d ON cl.id = d.productId
    WHERE cl.firm = $1 OR cl.line = $2
)
SELECT 
    minprice,
    id,
    image_path,
    name,
    firm,
    maxdiscprice,
    producttype,
    FIRST_VALUE(total_count) OVER () AS total_count
FROM combined_products
ORDER BY name
LIMIT $3 OFFSET $4
`

type GetMerchCollectionWithCountParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetMerchCollectionWithCountRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Producttype  string      `json:"producttype"`
	TotalCount   interface{} `json:"total_count"`
}

func (q *Queries) GetMerchCollectionWithCount(ctx context.Context, arg GetMerchCollectionWithCountParams) ([]GetMerchCollectionWithCountRow, error) {
	rows, err := q.db.Query(ctx, getMerchCollectionWithCount,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCollectionWithCountRow
	for rows.Next() {
		var i GetMerchCollectionWithCountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Producttype,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCountIdByName = `-- name: GetMerchCountIdByName :many
SELECT firm, SUM(count) as count
FROM (

    SELECT firm, COUNT(id) as count
    FROM snickers
    WHERE name ILIKE '%' || $1::text || '%'
    GROUP BY firm
    
    UNION ALL

    SELECT firm, COUNT(id) as count
    FROM solomerch
    WHERE name ILIKE '%' || $1::text || '%'
    GROUP BY firm
) combined_results
GROUP BY firm
ORDER BY count DESC
`

type GetMerchCountIdByNameRow struct {
	Firm  string `json:"firm"`
	Count int64  `json:"count"`
}

func (q *Queries) GetMerchCountIdByName(ctx context.Context, dollar_1 string) ([]GetMerchCountIdByNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchCountIdByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchCountIdByNameRow
	for rows.Next() {
		var i GetMerchCountIdByNameRow
		if err := rows.Scan(&i.Firm, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchCountOfCollectionsOrFirms = `-- name: GetMerchCountOfCollectionsOrFirms :one
SELECT 
    (SELECT COUNT(id) FROM snickers WHERE snickers.firm = $1 OR snickers.line = $2) +
     (SELECT COUNT(id) FROM clothes WHERE clothes.firm = $1 OR clothes.line = $2) +
    (SELECT COUNT(id) FROM soloMerch WHERE soloMerch.firm = $1 OR soloMerch.line = $2) AS total_count
`

type GetMerchCountOfCollectionsOrFirmsParams struct {
	Firm string `json:"firm"`
	Line string `json:"line"`
}

func (q *Queries) GetMerchCountOfCollectionsOrFirms(ctx context.Context, arg GetMerchCountOfCollectionsOrFirmsParams) (int32, error) {
	row := q.db.QueryRow(ctx, getMerchCountOfCollectionsOrFirms, arg.Firm, arg.Line)
	var total_count int32
	err := row.Scan(&total_count)
	return total_count, err
}

const getMerchFiltersByString = `-- name: GetMerchFiltersByString :one
WITH combined_products AS (
    -- Данные из snickers
  
    
    -- Данные из solomerch
    SELECT 
        sm.minprice AS minprice,
        sm.minprice AS maxprice, -- Для solomerch используем price для обоих значений
        sm.firm,
        NULL, NULL, NULL, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL
    FROM solomerch sm
    WHERE sm.name ILIKE '%' || $1::text || '%'
),
firm_counts AS (
    SELECT firm, COUNT(*) AS firm_count
    FROM combined_products
    GROUP BY firm
)
SELECT

    MIN(cp.minprice) AS min_price,
    MAX(cp.maxprice) AS max_price,
    jsonb_object_agg(COALESCE(fc.firm, 'Unknown'), fc.firm_count) AS firm_count_map
FROM combined_products cp
LEFT JOIN firm_counts fc ON cp.firm = fc.firm
`

type GetMerchFiltersByStringRow struct {
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	FirmCountMap []byte      `json:"firm_count_map"`
}

func (q *Queries) GetMerchFiltersByString(ctx context.Context, dollar_1 string) (GetMerchFiltersByStringRow, error) {
	row := q.db.QueryRow(ctx, getMerchFiltersByString, dollar_1)
	var i GetMerchFiltersByStringRow
	err := row.Scan(&i.MinPrice, &i.MaxPrice, &i.FirmCountMap)
	return i, err
}

const getMerchFirms = `-- name: GetMerchFirms :many
SELECT 
    firm,
    array_agg(DISTINCT line) AS collections
FROM (
    SELECT firm, line FROM snickers WHERE line IS NOT NULL
    UNION ALL
    SELECT firm, line FROM soloMerch WHERE line IS NOT NULL
    UNION ALL
    SELECT firm, line FROM clothes WHERE line IS NOT NULL
) AS combined_products
GROUP BY firm
ORDER BY firm
`

type GetMerchFirmsRow struct {
	Firm        string      `json:"firm"`
	Collections interface{} `json:"collections"`
}

func (q *Queries) GetMerchFirms(ctx context.Context) ([]GetMerchFirmsRow, error) {
	rows, err := q.db.Query(ctx, getMerchFirms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchFirmsRow
	for rows.Next() {
		var i GetMerchFirmsRow
		if err := rows.Scan(&i.Firm, &i.Collections); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchProductsByFirmName = `-- name: GetMerchProductsByFirmName :many
(
    -- Товары из таблицы snickers
    SELECT 
        s.name,
        s.image_path,
        s.id,
        COALESCE(d.minprice, s.minprice) AS value,  -- Используем minprice как value
        s.article,
       'snickers' AS producttype
    FROM snickers s
    LEFT JOIN discount d ON s.id = d.productid  -- Связь по snickers_id
    WHERE s.firm = $1
)
UNION ALL
(
    -- Товары из таблицы soloMerch
    SELECT 
        sm.name,
        sm.image_path,
        sm.id,
        COALESCE(d.minprice, sm.minprice) AS value,  -- Используем price как value
        sm.article,
         'solomerch' AS producttype
    FROM solomerch sm
    LEFT JOIN discount d ON sm.id = d.productid  -- Связь по solo_merch_id
    WHERE sm.firm = $1
)
UNION ALL
(
    -- Товары из таблицы soloMerch
    SELECT 
        cl.name,
        cl.image_path,
        cl.id,
        COALESCE(d.minprice, cl.minprice) AS value,  -- Используем price как value
        cl.article,
         'clothes' AS producttype
    FROM clothes cl
    LEFT JOIN discount d ON cl.id = d.productid  -- Связь по solo_merch_id
    WHERE cl.firm = $1
)
ORDER BY name
`

type GetMerchProductsByFirmNameRow struct {
	Name        string      `json:"name"`
	ImagePath   string      `json:"image_path"`
	ID          int32       `json:"id"`
	Value       int32       `json:"value"`
	Article     pgtype.Text `json:"article"`
	Producttype string      `json:"producttype"`
}

func (q *Queries) GetMerchProductsByFirmName(ctx context.Context, firm string) ([]GetMerchProductsByFirmNameRow, error) {
	rows, err := q.db.Query(ctx, getMerchProductsByFirmName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchProductsByFirmNameRow
	for rows.Next() {
		var i GetMerchProductsByFirmNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchWithDiscount = `-- name: GetMerchWithDiscount :many
(
    -- Данные из таблицы snickers
    SELECT 
        s.minPrice,
        s.qId,
        s.id,
        s.image_path,
        s.name,
        s.firm,
        d.maxdiscprice,
         'snickers' AS producttype
    FROM snickers s
    JOIN discount d ON s.id = d.productId
)
UNION ALL
(
    -- Данные из таблицы soloMerch
    SELECT 
        sm.minprice,  -- Используем price вместо minprice
        sm.qId,
        sm.id,
        sm.image_path,
        sm.name,
        sm.firm,
        d.maxdiscprice,
         'solomerch' AS producttype
    FROM solomerch sm
    JOIN discount d ON sm.id = d.productId
)
UNION ALL
(
    -- Данные из таблицы soloMerch
    SELECT 
        cl.minprice,  -- Используем price вместо minprice
        cl.qId,
        cl.id,
        cl.image_path,
        cl.name,
        cl.firm,
        d.maxdiscprice,
        'clothes' AS producttype
    FROM clothes cl
    JOIN discount d ON cl.id = d.productId
)
`

type GetMerchWithDiscountRow struct {
	Minprice     int32       `json:"minprice"`
	Qid          string      `json:"qid"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Producttype  string      `json:"producttype"`
}

func (q *Queries) GetMerchWithDiscount(ctx context.Context) ([]GetMerchWithDiscountRow, error) {
	rows, err := q.db.Query(ctx, getMerchWithDiscount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchWithDiscountRow
	for rows.Next() {
		var i GetMerchWithDiscountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.Qid,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSource = `-- name: GetProductSource :one
SELECT source_table, internal_id 
FROM product_registry 
WHERE global_id = $1
`

type GetProductSourceRow struct {
	SourceTable ProductSourceEnum `json:"source_table"`
	InternalID  int32             `json:"internal_id"`
}

func (q *Queries) GetProductSource(ctx context.Context, globalID int32) (GetProductSourceRow, error) {
	row := q.db.QueryRow(ctx, getProductSource, globalID)
	var i GetProductSourceRow
	err := row.Scan(&i.SourceTable, &i.InternalID)
	return i, err
}

const getSnickersByFirmName = `-- name: GetSnickersByFirmName :many
SELECT name,
    image_path,
    snickers.id,
    value,
    article
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE firm = $1
`

type GetSnickersByFirmNameRow struct {
	Name      string      `json:"name"`
	ImagePath string      `json:"image_path"`
	ID        int32       `json:"id"`
	Value     []byte      `json:"value"`
	Article   pgtype.Text `json:"article"`
}

func (q *Queries) GetSnickersByFirmName(ctx context.Context, firm string) ([]GetSnickersByFirmNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByFirmName, firm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByFirmNameRow
	for rows.Next() {
		var i GetSnickersByFirmNameRow
		if err := rows.Scan(
			&i.Name,
			&i.ImagePath,
			&i.ID,
			&i.Value,
			&i.Article,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByIds = `-- name: GetSnickersByIds :many
SELECT 
    COALESCE(d.minprice, s.minprice) AS price,
    s.id,
    s.image_path, 
    s.name, 
    s.firm, 
    d.maxdiscprice
FROM snickers s
LEFT JOIN discount d ON s.id = d.productid 
WHERE s.id = ANY($1::int[])
`

type GetSnickersByIdsRow struct {
	Price        int32       `json:"price"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
}

func (q *Queries) GetSnickersByIds(ctx context.Context, dollar_1 []int32) ([]GetSnickersByIdsRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByIdsRow
	for rows.Next() {
		var i GetSnickersByIdsRow
		if err := rows.Scan(
			&i.Price,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByLineName = `-- name: GetSnickersByLineName :many
SELECT line,
    array_agg(id) AS id,
    array_agg(image_path) AS image_path,
    array_agg(name) AS name_data
FROM snickers
WHERE line = $1
GROUP BY line
`

type GetSnickersByLineNameRow struct {
	Line      string      `json:"line"`
	ID        interface{} `json:"id"`
	ImagePath interface{} `json:"image_path"`
	NameData  interface{} `json:"name_data"`
}

func (q *Queries) GetSnickersByLineName(ctx context.Context, line string) ([]GetSnickersByLineNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByLineName, line)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByLineNameRow
	for rows.Next() {
		var i GetSnickersByLineNameRow
		if err := rows.Scan(
			&i.Line,
			&i.ID,
			&i.ImagePath,
			&i.NameData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersByName = `-- name: GetSnickersByName :many
SELECT snickers.minPrice,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice,
    'snickers' AS producttype
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE name ILIKE '%' || $1::text || '%'
LIMIT $2
`

type GetSnickersByNameParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

type GetSnickersByNameRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	Producttype  string      `json:"producttype"`
}

func (q *Queries) GetSnickersByName(ctx context.Context, arg GetSnickersByNameParams) ([]GetSnickersByNameRow, error) {
	rows, err := q.db.Query(ctx, getSnickersByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersByNameRow
	for rows.Next() {
		var i GetSnickersByNameRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.Producttype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnickersInfoById = `-- name: GetSnickersInfoById :one
SELECT info,
    image_path,
    name,
    value,
    article,
    description,
    date,
    image_count
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE snickers.id = $1
`

type GetSnickersInfoByIdRow struct {
	Info        []byte      `json:"info"`
	ImagePath   string      `json:"image_path"`
	Name        string      `json:"name"`
	Value       []byte      `json:"value"`
	Article     pgtype.Text `json:"article"`
	Description pgtype.Text `json:"description"`
	Date        pgtype.Text `json:"date"`
	ImageCount  int32       `json:"image_count"`
}

func (q *Queries) GetSnickersInfoById(ctx context.Context, id int32) (GetSnickersInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getSnickersInfoById, id)
	var i GetSnickersInfoByIdRow
	err := row.Scan(
		&i.Info,
		&i.ImagePath,
		&i.Name,
		&i.Value,
		&i.Article,
		&i.Description,
		&i.Date,
		&i.ImageCount,
	)
	return i, err
}

const getSnickersWithDiscount = `-- name: GetSnickersWithDiscount :many
SELECT snickers.minPrice,
    snickers.qId,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice
FROM snickers
    JOIN discount ON snickers.id = productid
`

type GetSnickersWithDiscountRow struct {
	Minprice     int32       `json:"minprice"`
	Qid          string      `json:"qid"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
}

func (q *Queries) GetSnickersWithDiscount(ctx context.Context) ([]GetSnickersWithDiscountRow, error) {
	rows, err := q.db.Query(ctx, getSnickersWithDiscount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnickersWithDiscountRow
	for rows.Next() {
		var i GetSnickersWithDiscountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.Qid,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloCollection = `-- name: GetSoloCollection :many
SELECT COALESCE(discount.minprice, snickers.minprice) AS minprice,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE firm = $1
    OR line = $2
LIMIT $3 OFFSET $4
`

type GetSoloCollectionParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetSoloCollectionRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
}

func (q *Queries) GetSoloCollection(ctx context.Context, arg GetSoloCollectionParams) ([]GetSoloCollectionRow, error) {
	rows, err := q.db.Query(ctx, getSoloCollection,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoloCollectionRow
	for rows.Next() {
		var i GetSoloCollectionRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloCollectionWithCount = `-- name: GetSoloCollectionWithCount :many
SELECT COALESCE(discount.minprice, snickers.minprice) AS minprice,
    snickers.id,
    image_path,
    name,
    firm,
    maxdiscprice,
    COUNT(*) OVER () AS total_count
FROM snickers
    LEFT JOIN discount ON snickers.id = productid
WHERE firm = $1
    OR line = $2
LIMIT $3 OFFSET $4
`

type GetSoloCollectionWithCountParams struct {
	Firm   string `json:"firm"`
	Line   string `json:"line"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetSoloCollectionWithCountRow struct {
	Minprice     int32       `json:"minprice"`
	ID           int32       `json:"id"`
	ImagePath    string      `json:"image_path"`
	Name         string      `json:"name"`
	Firm         string      `json:"firm"`
	Maxdiscprice pgtype.Int4 `json:"maxdiscprice"`
	TotalCount   int64       `json:"total_count"`
}

func (q *Queries) GetSoloCollectionWithCount(ctx context.Context, arg GetSoloCollectionWithCountParams) ([]GetSoloCollectionWithCountRow, error) {
	rows, err := q.db.Query(ctx, getSoloCollectionWithCount,
		arg.Firm,
		arg.Line,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoloCollectionWithCountRow
	for rows.Next() {
		var i GetSoloCollectionWithCountRow
		if err := rows.Scan(
			&i.Minprice,
			&i.ID,
			&i.ImagePath,
			&i.Name,
			&i.Firm,
			&i.Maxdiscprice,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloMerchInfoById = `-- name: GetSoloMerchInfoById :one
SELECT
    image_path,
    name,
    article,
    solomerch.minprice,
    description,
    date,
    image_count
FROM solomerch
    LEFT JOIN discount ON solomerch.id = productid
WHERE solomerch.id = $1
`

type GetSoloMerchInfoByIdRow struct {
	ImagePath   string      `json:"image_path"`
	Name        string      `json:"name"`
	Article     pgtype.Text `json:"article"`
	Minprice    int32       `json:"minprice"`
	Description pgtype.Text `json:"description"`
	Date        pgtype.Text `json:"date"`
	ImageCount  int32       `json:"image_count"`
}

func (q *Queries) GetSoloMerchInfoById(ctx context.Context, id int32) (GetSoloMerchInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getSoloMerchInfoById, id)
	var i GetSoloMerchInfoByIdRow
	err := row.Scan(
		&i.ImagePath,
		&i.Name,
		&i.Article,
		&i.Minprice,
		&i.Description,
		&i.Date,
		&i.ImageCount,
	)
	return i, err
}
