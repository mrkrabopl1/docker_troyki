// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCartData = `-- name: DeleteCartData :exec
DELETE FROM preorderitems
WHERE id = $1
`

func (q *Queries) DeleteCartData(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCartData, id)
	return err
}

const getFullPreorderCount = `-- name: GetFullPreorderCount :one
SELECT coalesce(SUM(quantity), 0)
FROM preorderItems
WHERE orderid = $1
`

func (q *Queries) GetFullPreorderCount(ctx context.Context, orderid int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getFullPreorderCount, orderid)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getOrder = `-- name: GetOrder :one
SELECT id,
    hash,
    status,
    customerId,
    unregistercustomerid,
    deliveryprice,
    deliverytype
FROM orders
WHERE hash = $1
`

type GetOrderRow struct {
	ID                   int32        `json:"id"`
	Hash                 string       `json:"hash"`
	Status               StatusEnum   `json:"status"`
	Customerid           pgtype.Int4  `json:"customerid"`
	Unregistercustomerid pgtype.Int4  `json:"unregistercustomerid"`
	Deliveryprice        int32        `json:"deliveryprice"`
	Deliverytype         DeliveryEnum `json:"deliverytype"`
}

func (q *Queries) GetOrder(ctx context.Context, hash string) (GetOrderRow, error) {
	row := q.db.QueryRow(ctx, getOrder, hash)
	var i GetOrderRow
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Status,
		&i.Customerid,
		&i.Unregistercustomerid,
		&i.Deliveryprice,
		&i.Deliverytype,
	)
	return i, err
}

const getOrderAddressById = `-- name: GetOrderAddressById :one
SELECT  id,
        town,
        street,
        region,
        index,
        house,
        flat,
        coordinates
FROM orderAddress
WHERE orderid = $1
`

type GetOrderAddressByIdRow struct {
	ID          int32       `json:"id"`
	Town        string      `json:"town"`
	Street      pgtype.Text `json:"street"`
	Region      pgtype.Text `json:"region"`
	Index       string      `json:"index"`
	House       pgtype.Text `json:"house"`
	Flat        pgtype.Text `json:"flat"`
	Coordinates []string    `json:"coordinates"`
}

func (q *Queries) GetOrderAddressById(ctx context.Context, orderid int32) (GetOrderAddressByIdRow, error) {
	row := q.db.QueryRow(ctx, getOrderAddressById, orderid)
	var i GetOrderAddressByIdRow
	err := row.Scan(
		&i.ID,
		&i.Town,
		&i.Street,
		&i.Region,
		&i.Index,
		&i.House,
		&i.Flat,
		&i.Coordinates,
	)
	return i, err
}

const getOrderById = `-- name: GetOrderById :one
SELECT id,
    hash,
    status,
    customerId,
    unregistercustomerid
FROM orders
WHERE id = $1
`

type GetOrderByIdRow struct {
	ID                   int32       `json:"id"`
	Hash                 string      `json:"hash"`
	Status               StatusEnum  `json:"status"`
	Customerid           pgtype.Int4 `json:"customerid"`
	Unregistercustomerid pgtype.Int4 `json:"unregistercustomerid"`
}

func (q *Queries) GetOrderById(ctx context.Context, id int32) (GetOrderByIdRow, error) {
	row := q.db.QueryRow(ctx, getOrderById, id)
	var i GetOrderByIdRow
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Status,
		&i.Customerid,
		&i.Unregistercustomerid,
	)
	return i, err
}

const getOrderDataById = `-- name: GetOrderDataById :many
SELECT 
  ProductId AS id,
    size,
    price,
    quantity,
    image_path,
    name
FROM orderItems
WHERE orderid = $1
`

type GetOrderDataByIdRow struct {
	ID        int32       `json:"id"`
	Size      pgtype.Text `json:"size"`
	Price     int32       `json:"price"`
	Quantity  int32       `json:"quantity"`
	ImagePath string      `json:"image_path"`
	Name      string      `json:"name"`
}

func (q *Queries) GetOrderDataById(ctx context.Context, orderid int32) ([]GetOrderDataByIdRow, error) {
	rows, err := q.db.Query(ctx, getOrderDataById, orderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderDataByIdRow
	for rows.Next() {
		var i GetOrderDataByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Price,
			&i.Quantity,
			&i.ImagePath,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderIdByHashUrl = `-- name: GetOrderIdByHashUrl :one
SELECT id
FROM orders
WHERE hash = $1
`

func (q *Queries) GetOrderIdByHashUrl(ctx context.Context, hash string) (int32, error) {
	row := q.db.QueryRow(ctx, getOrderIdByHashUrl, hash)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getOrderInfo = `-- name: GetOrderInfo :many
SELECT 
    (SELECT json_agg(a) FROM orderAddress a WHERE a.orderid = $1) AS address,
    (SELECT json_agg(i) FROM orderItems i WHERE i.orderid = $1) AS items
`

type GetOrderInfoRow struct {
	Address []byte `json:"address"`
	Items   []byte `json:"items"`
}

func (q *Queries) GetOrderInfo(ctx context.Context, orderid int32) ([]GetOrderInfoRow, error) {
	rows, err := q.db.Query(ctx, getOrderInfo, orderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderInfoRow
	for rows.Next() {
		var i GetOrderInfoRow
		if err := rows.Scan(&i.Address, &i.Items); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreorderAddressById = `-- name: GetPreorderAddressById :one
SELECT  id,
        town,
        street,
        region,
        index,
        house,
        flat,
        coordinates
FROM preorderAddress
WHERE orderid = $1
`

type GetPreorderAddressByIdRow struct {
	ID          int32       `json:"id"`
	Town        string      `json:"town"`
	Street      pgtype.Text `json:"street"`
	Region      pgtype.Text `json:"region"`
	Index       string      `json:"index"`
	House       pgtype.Text `json:"house"`
	Flat        pgtype.Text `json:"flat"`
	Coordinates []string    `json:"coordinates"`
}

func (q *Queries) GetPreorderAddressById(ctx context.Context, orderid int32) (GetPreorderAddressByIdRow, error) {
	row := q.db.QueryRow(ctx, getPreorderAddressById, orderid)
	var i GetPreorderAddressByIdRow
	err := row.Scan(
		&i.ID,
		&i.Town,
		&i.Street,
		&i.Region,
		&i.Index,
		&i.House,
		&i.Flat,
		&i.Coordinates,
	)
	return i, err
}

const getPreorderDataById = `-- name: GetPreorderDataById :many
SELECT 
    ProductId AS id,
    size,
    quantity,
    price,
    image_path,
    name
FROM preorderItems
WHERE orderid = $1
`

type GetPreorderDataByIdRow struct {
	ID        int32       `json:"id"`
	Size      pgtype.Text `json:"size"`
	Quantity  int32       `json:"quantity"`
	Price     int32       `json:"price"`
	ImagePath string      `json:"image_path"`
	Name      string      `json:"name"`
}

func (q *Queries) GetPreorderDataById(ctx context.Context, orderid int32) ([]GetPreorderDataByIdRow, error) {
	rows, err := q.db.Query(ctx, getPreorderDataById, orderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPreorderDataByIdRow
	for rows.Next() {
		var i GetPreorderDataByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Size,
			&i.Quantity,
			&i.Price,
			&i.ImagePath,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreorderIdByHashUrl = `-- name: GetPreorderIdByHashUrl :one
SELECT id
FROM preorder
WHERE hashUrl = $1
`

func (q *Queries) GetPreorderIdByHashUrl(ctx context.Context, hashurl string) (int32, error) {
	row := q.db.QueryRow(ctx, getPreorderIdByHashUrl, hashurl)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPreorderInfo = `-- name: GetPreorderInfo :many
SELECT 
    (SELECT json_agg(a) FROM preorderAddress a WHERE a.orderid = $1) AS address,
    (SELECT json_agg(i) FROM preorderItems i WHERE i.orderid = $1) AS items
`

type GetPreorderInfoRow struct {
	Address []byte `json:"address"`
	Items   []byte `json:"items"`
}

func (q *Queries) GetPreorderInfo(ctx context.Context, orderid int32) ([]GetPreorderInfoRow, error) {
	rows, err := q.db.Query(ctx, getPreorderInfo, orderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPreorderInfoRow
	for rows.Next() {
		var i GetPreorderInfoRow
		if err := rows.Scan(&i.Address, &i.Items); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertManyOrderItems = `-- name: InsertManyOrderItems :exec
INSERT INTO orderItems (productid, quantity, size, price, image_path, name, orderid)
SELECT 
    unnest($1::integer[]),
    unnest($2::integer[]),
    unnest($3::text[]),
    unnest($4::integer[]),
    unnest($5::text[]),
    unnest($6::text[]),
    $7::integer
WHERE 
    array_length($1::integer[], 1) IS NOT NULL
`

type InsertManyOrderItemsParams struct {
	ProductIds []int32  `json:"product_ids"`
	Quantities []int32  `json:"quantities"`
	Sizes      []string `json:"sizes"`
	Prices     []int32  `json:"prices"`
	ImagePaths []string `json:"image_paths"`
	Names      []string `json:"names"`
	OrderID    int32    `json:"order_id"`
}

func (q *Queries) InsertManyOrderItems(ctx context.Context, arg InsertManyOrderItemsParams) error {
	_, err := q.db.Exec(ctx, insertManyOrderItems,
		arg.ProductIds,
		arg.Quantities,
		arg.Sizes,
		arg.Prices,
		arg.ImagePaths,
		arg.Names,
		arg.OrderID,
	)
	return err
}

const insertManyPreorderItems = `-- name: InsertManyPreorderItems :exec
INSERT INTO preorderItems (productid, quantity, size, orderid)
SELECT 
    (item->>'product_id')::int,
    (item->>'quantity')::int,
    item->>'size',
    $1::int
FROM jsonb_array_elements($2::jsonb) AS item
`

type InsertManyPreorderItemsParams struct {
	PreorderID int32  `json:"preorder_id"`
	Items      []byte `json:"items"`
}

func (q *Queries) InsertManyPreorderItems(ctx context.Context, arg InsertManyPreorderItemsParams) error {
	_, err := q.db.Exec(ctx, insertManyPreorderItems, arg.PreorderID, arg.Items)
	return err
}

const insertOrder = `-- name: InsertOrder :one
INSERT INTO orders (
        status,
        deliveryPrice,
        deliveryType,
        unregistercustomerid,
        hash
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertOrderParams struct {
	Status               StatusEnum   `json:"status"`
	Deliveryprice        int32        `json:"deliveryprice"`
	Deliverytype         DeliveryEnum `json:"deliverytype"`
	Unregistercustomerid pgtype.Int4  `json:"unregistercustomerid"`
	Hash                 string       `json:"hash"`
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertOrder,
		arg.Status,
		arg.Deliveryprice,
		arg.Deliverytype,
		arg.Unregistercustomerid,
		arg.Hash,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertOrderItems = `-- name: InsertOrderItems :exec
INSERT INTO orderItems (
    orderid,
    ProductId,
    quantity,
    size,
    price
) VALUES (
    $1,  -- orderid
   $2,  -- snickersId (assuming 0 means NULL)
   $3,  -- soloMerchId (assuming 0 means NULL)
    $4,  -- quantity
    $5
)
`

type InsertOrderItemsParams struct {
	Orderid   int32       `json:"orderid"`
	Productid int32       `json:"productid"`
	Quantity  int32       `json:"quantity"`
	Size      pgtype.Text `json:"size"`
	Price     int32       `json:"price"`
}

func (q *Queries) InsertOrderItems(ctx context.Context, arg InsertOrderItemsParams) error {
	_, err := q.db.Exec(ctx, insertOrderItems,
		arg.Orderid,
		arg.Productid,
		arg.Quantity,
		arg.Size,
		arg.Price,
	)
	return err
}

const insertPreorder = `-- name: InsertPreorder :one
INSERT INTO preorder (hashurl, updatetime)
VALUES ($1, $2)
RETURNING id
`

type InsertPreorderParams struct {
	Hashurl    string      `json:"hashurl"`
	Updatetime pgtype.Date `json:"updatetime"`
}

func (q *Queries) InsertPreorder(ctx context.Context, arg InsertPreorderParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertPreorder, arg.Hashurl, arg.Updatetime)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPreorderItem = `-- name: InsertPreorderItem :one
INSERT INTO preorderItems (
    orderid,
    ProductId,
    size,
    price,
    image_path,
    name,
    quantity

) VALUES (
    $1,  -- orderid
    $2,  -- snickersId (0 преобразуется в NULL)
    $3,  -- soloMerchId (0 преобразуется в NULL)
    $4,  -- price (0 преобразуется в NULL)
    $5,  -- image_path
    $6,  -- name
    1    -- quantity
)
RETURNING id
`

type InsertPreorderItemParams struct {
	Orderid   int32       `json:"orderid"`
	Productid int32       `json:"productid"`
	Size      pgtype.Text `json:"size"`
	Price     int32       `json:"price"`
	ImagePath string      `json:"image_path"`
	Name      string      `json:"name"`
}

func (q *Queries) InsertPreorderItem(ctx context.Context, arg InsertPreorderItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertPreorderItem,
		arg.Orderid,
		arg.Productid,
		arg.Size,
		arg.Price,
		arg.ImagePath,
		arg.Name,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const selectQuantityFromPreorderItems = `-- name: SelectQuantityFromPreorderItems :one
SELECT quantity
FROM preorderitems
WHERE orderid = $1
    AND size = $2
    AND productid = $3
`

type SelectQuantityFromPreorderItemsParams struct {
	Orderid   int32       `json:"orderid"`
	Size      pgtype.Text `json:"size"`
	Productid int32       `json:"productid"`
}

func (q *Queries) SelectQuantityFromPreorderItems(ctx context.Context, arg SelectQuantityFromPreorderItemsParams) (int32, error) {
	row := q.db.QueryRow(ctx, selectQuantityFromPreorderItems, arg.Orderid, arg.Size, arg.Productid)
	var quantity int32
	err := row.Scan(&quantity)
	return quantity, err
}

const setOrderAddress = `-- name: SetOrderAddress :one
INSERT INTO orderAddress (
        town,
        street,
        region,
        index,
        house,
        flat,
        orderId,
        coordinates
    )
VALUES ($1, $2, $3, $4,$5,$6,$7,$8)
RETURNING id
`

type SetOrderAddressParams struct {
	Town        string      `json:"town"`
	Street      pgtype.Text `json:"street"`
	Region      pgtype.Text `json:"region"`
	Index       string      `json:"index"`
	House       pgtype.Text `json:"house"`
	Flat        pgtype.Text `json:"flat"`
	Orderid     int32       `json:"orderid"`
	Coordinates []string    `json:"coordinates"`
}

func (q *Queries) SetOrderAddress(ctx context.Context, arg SetOrderAddressParams) (int32, error) {
	row := q.db.QueryRow(ctx, setOrderAddress,
		arg.Town,
		arg.Street,
		arg.Region,
		arg.Index,
		arg.House,
		arg.Flat,
		arg.Orderid,
		arg.Coordinates,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const setPreorderAddress = `-- name: SetPreorderAddress :one
INSERT INTO preorderAddress (
        town,
        street,
        region,
        index,
        house,
        flat,
        orderId,
        coordinates
    )
VALUES ($1, $2, $3, $4,$5,$6,$7,$8)
RETURNING id
`

type SetPreorderAddressParams struct {
	Town        string      `json:"town"`
	Street      pgtype.Text `json:"street"`
	Region      pgtype.Text `json:"region"`
	Index       string      `json:"index"`
	House       pgtype.Text `json:"house"`
	Flat        pgtype.Text `json:"flat"`
	Orderid     int32       `json:"orderid"`
	Coordinates []string    `json:"coordinates"`
}

func (q *Queries) SetPreorderAddress(ctx context.Context, arg SetPreorderAddressParams) (int32, error) {
	row := q.db.QueryRow(ctx, setPreorderAddress,
		arg.Town,
		arg.Street,
		arg.Region,
		arg.Index,
		arg.House,
		arg.Flat,
		arg.Orderid,
		arg.Coordinates,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updatePreorderItems = `-- name: UpdatePreorderItems :exec
UPDATE preorderItems
SET quantity = $1
WHERE orderid = $2
    AND size = $3
    AND productid = $4
`

type UpdatePreorderItemsParams struct {
	Quantity  int32       `json:"quantity"`
	Orderid   int32       `json:"orderid"`
	Size      pgtype.Text `json:"size"`
	Productid int32       `json:"productid"`
}

func (q *Queries) UpdatePreorderItems(ctx context.Context, arg UpdatePreorderItemsParams) error {
	_, err := q.db.Exec(ctx, updatePreorderItems,
		arg.Quantity,
		arg.Orderid,
		arg.Size,
		arg.Productid,
	)
	return err
}
